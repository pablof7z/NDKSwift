This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  commands/
    import
  settings.local.json
.roo/
  mcp.json
.tenex/
  metadata.json
  nostr.json
Sources/
  NDKSwift/
    Blossom/
      BlossomClient.swift
      BlossomTypes.swift
      NDKBlossomExtensions.swift
    Cache/
      NDKCacheAdapter.swift
      NDKFileCache.swift
      NDKFileCacheOutbox.swift
      NDKInMemoryCache.swift
      NDKOutboxCacheAdapter.swift
    Core/
      SignatureVerification/
        NDKSignatureVerificationCache.swift
        NDKSignatureVerificationSampler.swift
        NDKSignatureVerificationTypes.swift
      NDK.swift
      NDKOutbox.swift
      NDKProfileManager.swift
      Types.swift
    Models/
      Kinds/
        NDKCashuMintList.swift
        NDKContactList.swift
        NDKImage.swift
        NDKList.swift
        NDKNutzap.swift
        NDKRelayList.swift
      NDKEvent.swift
      NDKFilter.swift
      NDKRelay.swift
      NDKUser.swift
    Outbox/
      LRUCache.swift
      NDKEventExtensions.swift
      NDKFetchingStrategy.swift
      NDKOutboxItem.swift
      NDKOutboxTracker.swift
      NDKPublishingStrategy.swift
      NDKRelayPoolExtensions.swift
      NDKRelayRanker.swift
      NDKRelaySelector.swift
    Relay/
      NDKRelayConnection.swift
      NDKRelaySubscriptionManager.swift
      NostrMessage.swift
    Signers/
      NDKBunkerSigner.swift
      NDKNostrRPC.swift
      NDKPrivateKeySigner.swift
      NDKSigner.swift
    Subscription/
      NDKSubscription.swift
      NDKSubscriptionActors.swift
      NDKSubscriptionManager.swift
      NDKSubscriptionRefactored.swift
      NDKSubscriptionTracker.swift
      NDKSubscriptionTrackingTypes.swift
    Utils/
      Bech32.swift
      ContentTagger.swift
      Crypto.swift
      DataExtensions.swift
      FileManagerExtensions.swift
      ImetaUtils.swift
      JSONCoding.swift
      NostrIdentifier.swift
      RetryPolicy.swift
      URLNormalizer.swift
    Wallet/
      NDKCashuWallet.swift
      NDKPaymentRouter.swift
      NDKWallet.swift
    NDKSwift.swift
.gitignore
.repomixignore
.swift-version
.swiftlint.yml
.tenex.json
debug_key_generation.swift
debug_nsec.swift
Package.resolved
Package.swift
test_minimal.swift
test_race_condition.swift
test_race_fix.swift
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(grep:*)",
      "Bash(git add:*)",
      "Bash(swift build)",
      "Bash(swift test:*)",
      "Bash(swift build:*)",
      "Bash(rm:*)",
      "Bash(swift package:*)",
      "Bash(git describe:*)",
      "Bash(git tag:*)",
      "Bash(git push:*)",
      "Bash(xcrun simctl list:*)",
      "Bash(xcrun simctl boot:*)",
      "Bash(true)",
      "Bash(xcrun simctl install:*)",
      "Bash(xcrun simctl launch:*)",
      "Bash(open:*)",
      "Bash(xcodebuild:*)",
      "Bash(ls:*)",
      "Bash(mv:*)",
      "Bash(find:*)",
      "Bash(swift run:*)",
      "Bash(chmod:*)",
      "Bash(just:*)"
    ],
    "deny": []
  }
}
</file>

<file path="Sources/NDKSwift/Subscription/NDKSubscriptionActors.swift">
/// Actor for managing subscription state in a thread-safe manner
actor SubscriptionState {
// Relay management
private var activeRelays: Set<NDKRelay> = []
⋮----
// State flags
private var isActive: Bool = false
private var isClosed: Bool = false
private var eoseReceived: Bool = false
⋮----
// EOSE tracking
private var eoseReceivedFromRelays: Set<String> = []
⋮----
// Event deduplication
private var receivedEventIds: Set<EventID> = []
⋮----
// Stored events
private var events: [NDKEvent] = []
⋮----
// MARK: - Relay Management
⋮----
func addRelay(_ relay: NDKRelay) {
⋮----
func getAllRelays() -> Set<NDKRelay> {
⋮----
func removeAllRelays() -> Set<NDKRelay> {
let relays = activeRelays
⋮----
func contains(_ relay: NDKRelay) -> Bool {
⋮----
var relayCount: Int {
⋮----
// MARK: - State Management
⋮----
func activate() -> Bool {
⋮----
func deactivate() -> Bool {
⋮----
func getActiveStatus() -> (active: Bool, closed: Bool) {
⋮----
func isClosedStatus() -> Bool {
⋮----
// MARK: - EOSE Management
⋮----
func markEOSEReceived(fromRelay relayUrl: String, expectedRelayUrls: Set<String>) -> (allReceived: Bool, shouldNotify: Bool) {
⋮----
let allEoseReceived = expectedRelayUrls.isSubset(of: eoseReceivedFromRelays)
var shouldNotify = false
⋮----
func hasReceivedEOSE() -> Bool {
⋮----
// MARK: - Event Management
⋮----
func addEventIfNew(_ event: NDKEvent) -> (isNew: Bool, currentCount: Int) {
⋮----
let isNew = !receivedEventIds.contains(eventId)
⋮----
func getAllEvents() -> [NDKEvent] {
⋮----
func getEventCount() -> Int {
⋮----
/// Actor for managing subscription callbacks
actor CallbackManager {
private var eventCallbacks: [(NDKEvent) -> Void] = []
private var eoseCallbacks: [() -> Void] = []
private var errorCallbacks: [(Error) -> Void] = []
⋮----
// MARK: - Registration
⋮----
func addEventCallback(_ callback: @escaping (NDKEvent) -> Void) {
⋮----
func addEOSECallback(_ callback: @escaping () -> Void) {
⋮----
func addErrorCallback(_ callback: @escaping (Error) -> Void) {
⋮----
// MARK: - Execution
⋮----
func executeEventCallbacks(with event: NDKEvent) {
⋮----
func executeEOSECallbacks() {
⋮----
func executeErrorCallbacks(with error: Error) {
⋮----
// MARK: - Cleanup
⋮----
func removeAllCallbacks() {
⋮----
// MARK: - Stream Support
⋮----
func removeEventCallback(at index: Int) {
⋮----
func removeEOSECallback(at index: Int) {
⋮----
func getEventCallbackCount() -> Int {
⋮----
func getEOSECallbackCount() -> Int {
</file>

<file path="Sources/NDKSwift/Subscription/NDKSubscriptionRefactored.swift">
/// Actor for managing all subscription state in a thread-safe manner
actor SubscriptionStateManager {
// Relay management
private var activeRelays: Set<NDKRelay> = []
⋮----
// State flags
private var isActive: Bool = false
private var isClosed: Bool = false
private var eoseReceived: Bool = false
⋮----
// EOSE tracking
private var eoseReceivedFromRelays: Set<String> = []
⋮----
// Event management
private var events: [NDKEvent] = []
private var receivedEventIds: Set<EventID> = []
⋮----
// MARK: - Relay Management
⋮----
func addRelay(_ relay: NDKRelay) {
⋮----
func getAllRelays() -> Set<NDKRelay> {
⋮----
func removeAllRelays() -> Set<NDKRelay> {
let relays = activeRelays
⋮----
func contains(_ relay: NDKRelay) -> Bool {
⋮----
var relayCount: Int {
⋮----
// MARK: - State Management
⋮----
func setActive(_ active: Bool) {
⋮----
func setClosed(_ closed: Bool) {
⋮----
func setEoseReceived(_ received: Bool) {
⋮----
func getState() -> (isActive: Bool, isClosed: Bool, eoseReceived: Bool) {
⋮----
// MARK: - EOSE Tracking
⋮----
func markEoseReceived(from relay: NDKRelay) {
⋮----
// Check if all active relays have sent EOSE
let allRelayUrls = activeRelays.map { $0.url }
⋮----
func hasReceivedEose(from relay: NDKRelay) -> Bool {
⋮----
func isEoseComplete() -> Bool {
⋮----
// MARK: - Event Management
⋮----
func addEvent(_ event: NDKEvent) -> Bool {
⋮----
// Check for duplicate
⋮----
func getEvents() -> [NDKEvent] {
⋮----
func getEventCount() -> Int {
⋮----
func hasReceivedEvent(withId id: EventID) -> Bool {
⋮----
// MARK: - Cleanup
⋮----
func reset() {
⋮----
/// Actor for managing subscription callbacks
actor CallbackManager {
// Callback arrays
private var eventCallbacks: [(NDKEvent) -> Void] = []
private var eoseCallbacks: [() -> Void] = []
private var errorCallbacks: [(Error) -> Void] = []
⋮----
// MARK: - Registration
⋮----
func addEventCallback(_ callback: @escaping (NDKEvent) -> Void) {
⋮----
func addEoseCallback(_ callback: @escaping () -> Void) {
⋮----
func addErrorCallback(_ callback: @escaping (Error) -> Void) {
⋮----
// MARK: - Execution
⋮----
func executeEventCallbacks(with event: NDKEvent) {
⋮----
func executeEoseCallbacks() {
⋮----
func executeErrorCallbacks(with error: Error) {
⋮----
func removeAllCallbacks() {
⋮----
func getCallbackCounts() -> (events: Int, eose: Int, errors: Int) {
⋮----
/// Refactored NDKSubscription using actors instead of NSLocks
public final class NDKSubscriptionRefactored {
/// Unique subscription ID
public let id: String
⋮----
/// Filters for this subscription
public let filters: [NDKFilter]
⋮----
/// Subscription options
public let options: NDKSubscriptionOptions
⋮----
/// Reference to NDK instance
public weak var ndk: NDK?
⋮----
/// Subscription delegate
public weak var delegate: NDKSubscriptionDelegate?
⋮----
/// State manager actor
private let stateManager = SubscriptionStateManager()
⋮----
/// Callback manager actor
private let callbackManager = CallbackManager()
⋮----
/// Task for registration with subscription manager
var registrationTask: Task<Void, Never>?
⋮----
/// Timeout timer
private var timeoutTimer: Timer?
⋮----
// MARK: - Computed Properties (Async)
⋮----
/// Events received so far
public var events: [NDKEvent] {
⋮----
/// Whether EOSE has been received from all relays
public var eoseReceived: Bool {
⋮----
/// Whether the subscription is active
public var isActive: Bool {
⋮----
/// Whether the subscription is closed
public var isClosed: Bool {
⋮----
/// Active relays for this subscription
public var activeRelays: Set<NDKRelay> {
⋮----
// MARK: - Initialization
⋮----
public init(
⋮----
// Set up timeout if specified
⋮----
deinit {
⋮----
// MARK: - Lifecycle Methods
⋮----
/// Start the subscription
public func start() {
⋮----
// Add to subscription manager if not already added
⋮----
/// Stop the subscription
public func stop() {
⋮----
/// Close the subscription
public func close() async {
let state = await stateManager.getState()
⋮----
// Cancel timeout
⋮----
// Get all active relays before clearing
let relays = await stateManager.removeAllRelays()
⋮----
// Remove from subscription manager
⋮----
// Clear callbacks
⋮----
// MARK: - Event Handling
⋮----
/// Process an incoming event
public func processEvent(_ event: NDKEvent, from relay: NDKRelay) async {
⋮----
// Try to add event (returns false if duplicate)
let isNewEvent = await stateManager.addEvent(event)
⋮----
// Notify delegate
⋮----
// Execute callbacks
⋮----
/// Process EOSE from a relay
public func processEOSE(from relay: NDKRelay) async {
⋮----
// Check if all relays have sent EOSE
let isComplete = await stateManager.isEoseComplete()
⋮----
// Close if configured
⋮----
/// Process an error
public func processError(_ error: Error) async {
⋮----
/// Add a relay to this subscription
public func addRelay(_ relay: NDKRelay) async {
⋮----
/// Check if subscription is active on a relay
public func isActive(on relay: NDKRelay) async -> Bool {
⋮----
// MARK: - Callbacks (Backward Compatibility)
⋮----
/// Add event callback
public func onEvent(_ callback: @escaping (NDKEvent) -> Void) {
⋮----
/// Add EOSE callback
public func onEose(_ callback: @escaping () -> Void) {
⋮----
/// Add error callback
public func onError(_ callback: @escaping (Error) -> Void) {
⋮----
/// Wait for EOSE
public func waitForEOSE() async {
⋮----
// Check if already received
⋮----
// Otherwise wait for it
⋮----
// MARK: - Private Methods
⋮----
private func handleTimeout() async {
</file>

<file path=".claude/commands/import">
Analyze how the typescript reference implementation of NDK in ./ndk/ implements what the user is requesting. Come up with a comprehensive plan of how to implement this same functionality, while trying to remain idiomatic within a Swift library in NDKSwift.

Implement comphrehensive testing, build NDKSwift and run it until it works.

The user will provide a task ID, which you should use to provide regular updates via the mcp tool `publish_task_status_update`. Frequent and transparent communication is fundamental.

Functionality to implement:
$ARGUMENTS
</file>

<file path=".roo/mcp.json">
{
    "mcpServers": {
        "tenex": {
            "command": "npx",
            "args": ["tenex-mcp"],
            "alwaysAllow": [
                 "publish",
                 "publish_task_status_update"
            ],
            "env": {
                "NSEC": "nsec17zemkvzym7mxt7g89lcl8c4yujer20x6vzuczwmdudwfysgrvfls9k540m"
            }
        }
    }
}
</file>

<file path=".tenex/metadata.json">
{
    "name": "NDKSwift-sfodj5",
    "title": "NDKSwift-sfodj5",
    "description": "Project NDKSwift-sfodj5",
    "hashtags": [],
    "repoUrl": null,
    "projectNaddr": "naddr1qvzqqqruh5pzp75cf0tahv5z7plpdeaws7ex52nmnwgtwfr2g3m37r844evqrr6jqq85u3zt2dmkjen594ekvmmydg6sdzkye9",
    "template": null,
    "createdAt": "2025-06-07T13:11:37.169Z"
}
</file>

<file path=".tenex/nostr.json">
{
  "nsec": "nsec17zemkvzym7mxt7g89lcl8c4yujer20x6vzuczwmdudwfysgrvfls9k540m",
  "pubkey": "f90c292553cec556ce45dc224facd0741b8e40ceb00f645ce056ec2c0dc4f6b5"
}
</file>

<file path="Sources/NDKSwift/Signers/NDKNostrRPC.swift">
// MARK: - RPC Types
⋮----
public struct NDKRPCRequest {
let id: String
let pubkey: String
let method: String
let params: [String]
let event: NDKEvent
⋮----
public struct NDKRPCResponse {
⋮----
let result: String
let error: String?
⋮----
// MARK: - Nostr RPC Client
⋮----
public actor NDKNostrRPC {
private let ndk: NDK
private let localSigner: NDKPrivateKeySigner
private let relayUrls: [String]
private var encryptionScheme: NDKEncryptionScheme = .nip04
private var pendingRequests: [String: CheckedContinuation<NDKRPCResponse, Error>] = [:]
⋮----
init(ndk: NDK, localSigner: NDKPrivateKeySigner, relayUrls: [String]) {
⋮----
func parseEvent(_ event: NDKEvent) async throws -> Any {
let remoteUser = NDKUser(pubkey: event.pubkey)
⋮----
var decryptedContent: String
⋮----
// Try other encryption scheme
let otherScheme: NDKEncryptionScheme = encryptionScheme == .nip04 ? .nip44 : .nip04
⋮----
let id = json["id"] as? String ?? ""
⋮----
let result = json["result"] as? String ?? ""
let error = json["error"] as? String
⋮----
let response = NDKRPCResponse(
⋮----
// Resume any waiting continuation
⋮----
func sendRequest(to pubkey: String, method: String, params: [String], handler: ((NDKRPCResponse) -> Void)? = nil) async throws {
let id = UUID().uuidString.prefix(8).lowercased()
⋮----
let request: [String: Any] = [
⋮----
let requestData = try JSONSerialization.data(withJSONObject: request)
let requestString = String(data: requestData, encoding: .utf8) ?? ""
⋮----
let remoteUser = NDKUser(pubkey: pubkey)
let encryptedContent = try await localSigner.encrypt(recipient: remoteUser, value: requestString, scheme: encryptionScheme)
⋮----
let localPubkey = try await localSigner.pubkey
var event = NDKEvent(
⋮----
// Prepare target relays
let targetRelayUrls = relayUrls.isEmpty ? nil : Set(relayUrls)
⋮----
// Publish event
let publishDescription = targetRelayUrls != nil ? "to specific relays: \(relayUrls)" : "to all connected relays"
⋮----
let publishedRelays = try await (targetRelayUrls != nil
⋮----
// If publishing to specific relays failed, try direct send as fallback
⋮----
// If handler provided, call it when response arrives
⋮----
let response = try await waitForResponse(id: id)
⋮----
func sendRequest(to pubkey: String, method: String, params: [String]) async throws -> NDKRPCResponse {
⋮----
// Response is handled in parseEvent
⋮----
// Set up timeout
⋮----
private func waitForResponse(id: String) async throws -> NDKRPCResponse {
⋮----
private func setupTimeout(for id: String, continuation: CheckedContinuation<NDKRPCResponse, Error>, timeoutSeconds: UInt64 = 30) {
⋮----
private func handleTimeout(id: String, continuation: CheckedContinuation<NDKRPCResponse, Error>) async {
⋮----
private func attemptDirectSend(event: NDKEvent, to relayUrls: [String]) async {
⋮----
let eventMessage = NostrMessage.event(subscriptionId: nil, event: event)
</file>

<file path="Sources/NDKSwift/Utils/JSONCoding.swift">
/// Centralized JSON encoding/decoding utility for consistent behavior across NDKSwift
public enum JSONCoding {
⋮----
// MARK: - Encoders
⋮----
/// Standard JSON encoder with sorted keys and without escaping slashes
public static let encoder: JSONEncoder = {
let encoder = JSONEncoder()
⋮----
/// Pretty-printed JSON encoder for debugging
public static let prettyEncoder: JSONEncoder = {
⋮----
// MARK: - Decoders
⋮----
/// Standard JSON decoder
public static let decoder = JSONDecoder()
⋮----
// MARK: - Convenience Methods
⋮----
/// Encode an object to JSON data
public static func encode<T: Encodable>(_ value: T) throws -> Data {
⋮----
/// Encode an object to JSON string
public static func encodeToString<T: Encodable>(_ value: T) throws -> String {
let data = try encode(value)
⋮----
/// Decode JSON data to object
public static func decode<T: Decodable>(_ type: T.Type, from data: Data) throws -> T {
⋮----
/// Decode JSON string to object
public static func decode<T: Decodable>(_ type: T.Type, from string: String) throws -> T {
⋮----
/// Encode to dictionary representation
public static func encodeToDictionary<T: Encodable>(_ value: T) throws -> [String: Any] {
⋮----
/// Decode from dictionary representation
public static func decodeFromDictionary<T: Decodable>(_ type: T.Type, from dictionary: [String: Any]) throws -> T {
let data = try JSONSerialization.data(withJSONObject: dictionary)
⋮----
// MARK: - Specialized Methods
⋮----
/// Encode for Nostr message serialization (compact, no spaces)
public static func encodeForNostr<T: Encodable>(_ value: T) throws -> String {
let data = try encoder.encode(value)
⋮----
/// Safe decode with optional result
public static func safeDecode<T: Decodable>(_ type: T.Type, from data: Data) -> T? {
⋮----
/// Safe decode from string with optional result
public static func safeDecode<T: Decodable>(_ type: T.Type, from string: String) -> T? {
</file>

<file path="Sources/NDKSwift/Utils/NostrIdentifier.swift">
/// Utilities for working with Nostr identifiers (hex and bech32)
public enum NostrIdentifier {
⋮----
/// Create a filter from a hex ID or bech32 identifier
/// - Parameter identifier: A hex event ID or bech32 encoded string (note1..., nevent1..., naddr1...)
/// - Returns: An NDKFilter configured to fetch the specified event
/// - Throws: NDKError if the identifier is invalid
public static func createFilter(from identifier: String) throws -> NDKFilter {
// Check if it's a bech32 string
⋮----
let decoded = try ContentTagger.decodeNostrEntity(identifier)
⋮----
// Assume it's a hex event ID
</file>

<file path="Sources/NDKSwift/Utils/RetryPolicy.swift">
/// Retry policy configuration for network operations
public struct RetryPolicyConfiguration {
/// Initial delay between retries (in seconds)
public let initialDelay: TimeInterval
⋮----
/// Maximum delay between retries (in seconds)
public let maxDelay: TimeInterval
⋮----
/// Multiplier for exponential backoff
public let multiplier: Double
⋮----
/// Maximum number of retry attempts (nil for unlimited)
public let maxAttempts: Int?
⋮----
/// Jitter factor (0.0 to 1.0) to randomize delays
public let jitterFactor: Double
⋮----
/// Default configuration for relay connections
public static let relayConnection = RetryPolicyConfiguration(
⋮----
/// Default configuration for RPC requests
public static let rpcRequest = RetryPolicyConfiguration(
⋮----
/// Configuration for critical operations
public static let critical = RetryPolicyConfiguration(
⋮----
public init(
⋮----
self.jitterFactor = min(max(jitterFactor, 0.0), 1.0) // Clamp between 0 and 1
⋮----
/// Manages retry logic with exponential backoff
public final class RetryPolicy {
private let configuration: RetryPolicyConfiguration
private var currentDelay: TimeInterval
private var attemptCount: Int = 0
private let queue = DispatchQueue(label: "com.ndkswift.retrypolicy")
⋮----
/// Timer for scheduled retries
private var retryTimer: Timer?
⋮----
/// Whether retry is currently active
public private(set) var isRetrying: Bool = false
⋮----
public init(configuration: RetryPolicyConfiguration = .relayConnection) {
⋮----
/// Reset the retry policy to initial state
public func reset() {
⋮----
/// Calculate the next retry delay
public func nextDelay() -> TimeInterval? {
⋮----
// Check if we've exceeded max attempts
⋮----
// Calculate base delay
let baseDelay = min(currentDelay, configuration.maxDelay)
⋮----
// Add jitter
let jitterRange = baseDelay * configuration.jitterFactor
let jitter = Double.random(in: -jitterRange...jitterRange)
let delayWithJitter = max(0, baseDelay + jitter)
⋮----
// Update for next iteration
⋮----
/// Schedule a retry operation
public func scheduleRetry(operation: @escaping () -> Void) {
⋮----
// Max attempts reached
⋮----
/// Cancel any scheduled retry
public func cancel() {
⋮----
/// Get current retry statistics
public var statistics: (attempts: Int, currentDelay: TimeInterval, isRetrying: Bool) {
⋮----
/// Async/await support for RetryPolicy
⋮----
/// Execute an async operation with retry logic
public func execute<T>(
⋮----
// Check if we should retry this error
⋮----
// Get next delay or throw if max attempts reached
⋮----
// Wait for the delay
⋮----
/// Execute an async operation with retry logic and timeout
public func executeWithTimeout<T>(
⋮----
// Add the main operation task
⋮----
// Add timeout task
⋮----
// Return the first result (either success or timeout)
⋮----
// Cancel remaining tasks
</file>

<file path=".swift-version">
5.0
</file>

<file path=".tenex.json">
{
  "pubkey": "f90c292553cec556ce45dc224facd0741b8e40ceb00f645ce056ec2c0dc4f6b5",
  "title": "NDKSwift",
  "nsec": "nsec17zemkvzym7mxt7g89lcl8c4yujer20x6vzuczwmdudwfysgrvfls9k540m",
  "hashtags": [],
  "repoUrl": "git@github.com:pablof7z/NDKSwift.git",
  "eventId": "31933:fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52:NDKSwift-sfodj5"
}
</file>

<file path="test_minimal.swift">
// Minimal test to verify the subscription manager fix
⋮----
// Simple async sleep to simulate the test
⋮----
// Keep the script running
</file>

<file path="test_race_condition.swift">
// Simple test to check if race condition is fixed
⋮----
struct TestRaceCondition {
static func main() async {
⋮----
let ndk = NDK(relayUrls: ["wss://relay.damus.io"])
⋮----
// Small delay to ensure connection
⋮----
let event = try await ndk.fetchEvent("nevent1qqsdpepvgml06dcsfuuy0x0jhka9jtwpvqrh5ue6qxmtva2xje7n9aqf7whc7")
</file>

<file path="test_race_fix.swift">
// Summary of the race condition fix applied to NDKSwift
</file>

<file path="Sources/NDKSwift/Blossom/BlossomClient.swift">
/// Blossom client for interacting with Blossom servers
public actor BlossomClient {
private let urlSession: URLSession
private var serverCache: [String: BlossomServerDescriptor] = [:]
⋮----
public init(urlSession: URLSession = .shared) {
⋮----
// MARK: - BUD-01: Server Discovery
⋮----
/// Discover Blossom server capabilities
public func discoverServer(_ serverURL: String) async throws -> BlossomServerDescriptor {
// Check cache first
⋮----
let wellKnownURL = baseURL.appendingPathComponent(".well-known/blossom")
⋮----
var request = URLRequest(url: wellKnownURL)
⋮----
let descriptor = try JSONDecoder().decode(BlossomServerDescriptor.self, from: data)
⋮----
// Cache the descriptor
⋮----
// MARK: - BUD-02: Upload
⋮----
/// Upload a file to a Blossom server
public func upload(
⋮----
// Calculate SHA256
let sha256 = SHA256.hash(data: data)
let sha256Hex = sha256.compactMap { String(format: "%02x", $0) }.joined()
⋮----
// Check if we need to discover the server first
let descriptor = try? await discoverServer(serverURL)
⋮----
// Validate file size if server has limits
⋮----
// Validate mime type if server has restrictions
⋮----
// Construct upload URL
let uploadPath = descriptor?.uploadUrl ?? "/upload"
let uploadURL = baseURL.appendingPathComponent(uploadPath)
⋮----
var request = URLRequest(url: uploadURL)
⋮----
// Set headers
⋮----
let authHeader = try auth.authorizationHeaderValue()
⋮----
let uploadDescriptor = try JSONDecoder().decode(BlossomUploadDescriptor.self, from: responseData)
⋮----
// Verify SHA256 matches
⋮----
let errorMessage = String(data: responseData, encoding: .utf8)
⋮----
// MARK: - BUD-03: List
⋮----
/// List blobs on a Blossom server
public func list(
⋮----
let listPath = descriptor?.listUrl ?? "/list"
⋮----
var urlComponents = URLComponents(url: baseURL.appendingPathComponent(listPath), resolvingAgainstBaseURL: true)!
⋮----
// Add query parameters
var queryItems: [URLQueryItem] = []
⋮----
var request = URLRequest(url: listURL)
⋮----
let listResponse = try JSONDecoder().decode(BlossomListResponse.self, from: data)
⋮----
let errorMessage = String(data: data, encoding: .utf8)
⋮----
// MARK: - BUD-04: Delete
⋮----
/// Delete a blob from a Blossom server
public func delete(
⋮----
let deleteURL = baseURL.appendingPathComponent(sha256)
⋮----
var request = URLRequest(url: deleteURL)
⋮----
// Success
⋮----
// MARK: - Download
⋮----
/// Download a blob from a Blossom server
public func download(
⋮----
var request = URLRequest(url: url)
⋮----
// Verify SHA256
let downloadedSHA256 = SHA256.hash(data: data)
let downloadedHex = downloadedSHA256.compactMap { String(format: "%02x", $0) }.joined()
⋮----
// MARK: - Convenience Methods
⋮----
/// Upload with automatic auth creation
public func uploadWithAuth(
⋮----
// Create auth
let auth = try await BlossomAuth.createUploadAuth(
⋮----
/// Delete with automatic auth creation
public func deleteWithAuth(
⋮----
let auth = try await BlossomAuth.createDeleteAuth(
⋮----
/// List with automatic auth creation
public func listWithAuth(
⋮----
let auth = try await BlossomAuth.createListAuth(
</file>

<file path="Sources/NDKSwift/Blossom/NDKBlossomExtensions.swift">
// MARK: - NDK Extensions for Blossom
⋮----
/// Blossom client instance
private static let blossomClientKey = "blossomClient"
⋮----
/// Get or create the Blossom client
public var blossomClient: BlossomClient {
⋮----
let client = BlossomClient()
⋮----
/// Upload a file to Blossom servers
public func uploadToBlossom(
⋮----
// Use provided servers or discover from relay list
let targetServers: [String]
⋮----
var uploadedBlobs: [BlossomBlob] = []
var lastError: Error?
⋮----
// Try uploading to multiple servers
⋮----
let blob = try await blossomClient.uploadWithAuth(
⋮----
/// Discover Blossom servers from relay configurations
private func discoverBlossomServers() async -> [String] {
// In a real implementation, this would:
// 1. Query relays for NIP-89 application handler events
// 2. Look for Blossom server announcements
// 3. Check user's preferred servers from kind 10096 events
⋮----
// For now, return some known Blossom servers
⋮----
// MARK: - NDKEvent Extensions for Blossom
⋮----
/// Create a file metadata event (NIP-94) with Blossom URLs
static func createFileMetadata(
⋮----
var tags: [[String]] = []
⋮----
// Add URL tags for each blob
⋮----
// Add other metadata
⋮----
let pubkey = try await signer.pubkey
var event = NDKEvent(
⋮----
// Generate ID and sign
⋮----
/// Extract Blossom URLs from a file metadata event
func extractBlossomURLs() -> [(url: String, sha256: String)] {
⋮----
var urls: [(url: String, sha256: String)] = []
let urlTags = tags.filter { $0.first == "url" }
let sha256Tags = tags.filter { $0.first == "x" }
⋮----
let url = urlTag[1]
let sha256 = index < sha256Tags.count && sha256Tags[index].count > 1
⋮----
/// Create an image event with Blossom upload
static func createImageEvent(
⋮----
// Upload to Blossom
let blobs = try await ndk.uploadToBlossom(
⋮----
// Create image event with imeta tags
⋮----
// Add imeta tag
var imetaTag = ["imeta"]
⋮----
// Add alt text if provided
⋮----
// MARK: - Extension Data Storage
⋮----
/// Storage for extension data
private static var _extensionData = [String: Any]()
⋮----
/// Access extension data
private var extensionData: [String: Any] {
</file>

<file path="Sources/NDKSwift/Cache/NDKCacheAdapter.swift">
/// Protocol for cache adapters
public protocol NDKCacheAdapter: AnyObject {
/// Whether this cache is fast enough to query before hitting relays
⋮----
/// Whether the cache is ready to use
⋮----
/// Query events from cache
⋮----
/// Store an event in cache
⋮----
/// Fetch a user profile from cache
⋮----
/// Save a user profile to cache
⋮----
/// Load NIP-05 verification data
⋮----
/// Save NIP-05 verification data
⋮----
/// Update relay connection status
⋮----
/// Get relay connection status
⋮----
/// Add an unpublished event (for retry logic)
⋮----
/// Get unpublished events for a relay
⋮----
/// Remove an unpublished event after successful publish
⋮----
/// Cache entry with metadata
public struct NDKCacheEntry<T> {
public let value: T
public let cachedAt: Date
public let expiresAt: Date?
⋮----
public init(value: T, cachedAt: Date = Date(), expiresAt: Date? = nil) {
⋮----
public var isExpired: Bool {
</file>

<file path="Sources/NDKSwift/Cache/NDKInMemoryCache.swift">
/// In-memory implementation of NDKCacheAdapter
public final class NDKInMemoryCache: NDKCacheAdapter {
private var events: [EventID: NDKEvent] = [:]
private var eventsByFilter: [String: Set<EventID>] = [:]
private var profiles: [PublicKey: NDKCacheEntry<NDKUserProfile>] = [:]
private var nip05Cache: [String: (pubkey: PublicKey, relays: [String])] = [:]
private var relayStatus: [RelayURL: NDKRelayConnectionState] = [:]
private var unpublishedEvents: [RelayURL: Set<EventID>] = [:]
⋮----
private let queue = DispatchQueue(label: "com.ndkswift.inmemorycache", attributes: .concurrent)
⋮----
public var locking: Bool { true }
public var ready: Bool { true }
⋮----
public init() {}
⋮----
// MARK: - Event Management
⋮----
public func query(subscription: NDKSubscription) async -> [NDKEvent] {
⋮----
var results = Set<NDKEvent>()
⋮----
// Get all events that match this filter
let filterKey = self.filterKey(from: filter)
⋮----
// Also check all events if filter is broad
⋮----
public func setEvent(_ event: NDKEvent, filters: [NDKFilter], relay _: NDKRelay?) async {
⋮----
// Store the event
⋮----
// Index by filters
⋮----
let key = self.filterKey(from: filter)
⋮----
// Index by common queries
⋮----
// MARK: - Profile Management
⋮----
public func fetchProfile(pubkey: PublicKey) async -> NDKUserProfile? {
⋮----
public func saveProfile(pubkey: PublicKey, profile: NDKUserProfile) async {
⋮----
let entry = NDKCacheEntry(
⋮----
expiresAt: Date().addingTimeInterval(3600) // 1 hour cache
⋮----
// MARK: - NIP-05 Management
⋮----
public func loadNip05(_ nip05: String) async -> (pubkey: PublicKey, relays: [String])? {
⋮----
public func saveNip05(_ nip05: String, pubkey: PublicKey, relays: [String]) async {
⋮----
// MARK: - Relay Status
⋮----
public func updateRelayStatus(_ url: RelayURL, status: NDKRelayConnectionState) async {
⋮----
public func getRelayStatus(_ url: RelayURL) async -> NDKRelayConnectionState? {
⋮----
// MARK: - Unpublished Events
⋮----
public func addUnpublishedEvent(_ event: NDKEvent, relayUrls: [RelayURL]) async {
⋮----
// Also store the event itself
⋮----
public func getUnpublishedEvents(for relayUrl: RelayURL) async -> [NDKEvent] {
⋮----
let events = eventIds.compactMap { self.events[$0] }
⋮----
public func removeUnpublishedEvent(_ eventId: EventID, from relayUrl: RelayURL) async {
⋮----
// MARK: - Private Helpers
⋮----
private func filterKey(from filter: NDKFilter) -> String {
var parts: [String] = []
⋮----
private func isBroadFilter(_ filter: NDKFilter) -> Bool {
⋮----
private func indexEvent(_ event: NDKEvent) {
⋮----
// Index by author
let authorKey = "authors:\(event.pubkey)"
⋮----
// Index by kind
let kindKey = "kinds:\(event.kind)"
⋮----
// MARK: - Cache Management
⋮----
/// Clear all cached data
public func clear() async {
⋮----
/// Get cache statistics
public func statistics() async -> (events: Int, profiles: Int, nip05: Int) {
</file>

<file path="Sources/NDKSwift/Cache/NDKOutboxCacheAdapter.swift">
/// Extended cache adapter protocol with comprehensive outbox support
public protocol NDKOutboxCacheAdapter: NDKCacheAdapter {
// MARK: - Unpublished Event Management
⋮----
/// Store an unpublished event with detailed relay status
⋮----
/// Get all unpublished events with their status
⋮----
/// Update the status of an unpublished event for a specific relay
⋮----
/// Mark an unpublished event as globally succeeded
⋮----
/// Get unpublished events that need retry
⋮----
/// Clean up old published events
⋮----
// MARK: - Outbox Relay Information
⋮----
/// Store relay information for a user
⋮----
/// Get relay information for a user
⋮----
/// Store relay health metrics
⋮----
/// Get relay health metrics
⋮----
/// Record of an unpublished event with relay statuses
public struct UnpublishedEventRecord: Codable {
public let event: NDKEvent
public let targetRelays: Set<String>
public let relayStatuses: [String: RelayPublishStatus]
public let createdAt: Date
public let lastAttemptAt: Date?
public let publishConfig: StoredPublishConfig?
public let overallStatus: PublishStatus
⋮----
public init(
⋮----
/// Check if this event should be retried
public func shouldRetry(after interval: TimeInterval) -> Bool {
⋮----
return true // Never attempted
⋮----
/// Stored version of publish config (simplified for persistence)
public struct StoredPublishConfig: Codable {
public let minSuccessfulRelays: Int
public let maxRetries: Int
public let enablePow: Bool
public let maxPowDifficulty: Int?
⋮----
public init(from config: OutboxPublishConfig) {
⋮----
/// Relay health metrics for caching
public struct RelayHealthMetrics: Codable {
public let url: String
public let successRate: Double
public let avgResponseTime: TimeInterval
public let lastSuccessAt: Date?
public let lastFailureAt: Date?
public let totalRequests: Int
public let successfulRequests: Int
public let updatedAt: Date
⋮----
// MARK: - Default Implementation Extensions
⋮----
/// Default implementation that converts to legacy format
func addUnpublishedEvent(_ event: NDKEvent, relayUrls: [RelayURL]) async {
let targetRelays = Set(relayUrls)
⋮----
/// Default implementation that filters by relay
func getUnpublishedEvents(for relayUrl: RelayURL) async -> [NDKEvent] {
let allEvents = await getAllUnpublishedEvents()
⋮----
/// Default implementation that updates status
func removeUnpublishedEvent(_ eventId: EventID, from relayUrl: RelayURL) async {
</file>

<file path="Sources/NDKSwift/Core/SignatureVerification/NDKSignatureVerificationCache.swift">
/// Cache for storing already verified event signatures
/// This prevents re-verification of the same event across different relays
actor NDKSignatureVerificationCache {
/// Cache of verified signatures: eventId -> signature
private var verifiedSignatures: [EventID: Signature] = [:]
⋮----
/// Maximum number of signatures to cache
private let maxCacheSize: Int
⋮----
/// Order of insertion for LRU eviction
private var insertionOrder: [EventID] = []
⋮----
public init(maxCacheSize: Int = 10000) {
⋮----
/// Check if an event signature has been verified
/// - Parameters:
///   - eventId: The event ID to check
///   - signature: The signature to verify against
/// - Returns: true if the signature matches the cached verified signature
public func isVerified(eventId: EventID, signature: Signature) -> Bool {
⋮----
/// Add a verified signature to the cache
⋮----
///   - eventId: The event ID
///   - signature: The verified signature
public func addVerifiedSignature(eventId: EventID, signature: Signature) {
// Check if already cached
⋮----
// Move to end of insertion order
⋮----
// Add new signature
⋮----
// Evict oldest if cache is full
⋮----
/// Clear the entire cache
public func clear() {
⋮----
/// Get cache statistics
public func getStats() -> (cacheSize: Int, hitRate: Double) {
let cacheSize = verifiedSignatures.count
// Hit rate would need to be tracked with hit/miss counters
</file>

<file path="Sources/NDKSwift/Core/SignatureVerification/NDKSignatureVerificationTypes.swift">
/// Configuration for signature verification sampling
public struct NDKSignatureVerificationConfig {
/// The signature verification validation ratio for new relays (1.0 = verify all)
public var initialValidationRatio: Double
⋮----
/// The lowest validation ratio any single relay can have
public var lowestValidationRatio: Double
⋮----
/// When true, automatically blacklist relays that provide events with invalid signatures
public var autoBlacklistInvalidRelays: Bool
⋮----
/// Custom function to calculate validation ratio
public var validationRatioFunction: ((NDKRelay, Int, Int) -> Double)?
⋮----
/// Default configuration with full signature verification
public static let `default` = NDKSignatureVerificationConfig(
⋮----
/// Configuration that disables all signature verification (use with extreme caution)
public static let disabled = NDKSignatureVerificationConfig(
⋮----
/// Statistics for signature verification on a relay
public struct NDKRelaySignatureStats {
/// Number of events that had their signatures validated
public private(set) var validatedCount: Int = 0
⋮----
/// Number of events that were not validated (sampling skipped them)
public private(set) var nonValidatedCount: Int = 0
⋮----
/// Current validation ratio for this relay
public private(set) var currentValidationRatio: Double = 1.0
⋮----
/// Total events processed
public var totalEvents: Int {
⋮----
/// Add a validated event
mutating func addValidatedEvent() {
⋮----
/// Add a non-validated event
mutating func addNonValidatedEvent() {
⋮----
/// Update the validation ratio
mutating func updateValidationRatio(_ ratio: Double) {
⋮----
/// Result of a signature verification attempt
public enum NDKSignatureVerificationResult {
⋮----
case skipped // Skipped due to sampling
case cached // Already verified (cached result)
⋮----
/// Protocol for signature verification delegate
public protocol NDKSignatureVerificationDelegate: AnyObject {
/// Called when an invalid signature is detected
/// - Parameters:
///   - event: The event with invalid signature
///   - relay: The relay that provided the invalid signature
⋮----
/// Called when a relay is blacklisted for providing invalid signatures
/// - Parameter relay: The blacklisted relay
</file>

<file path="Sources/NDKSwift/Core/NDKOutbox.swift">
/// Extension to NDK for outbox model support
⋮----
// MARK: - Outbox Components
⋮----
/// Outbox tracker for relay information
var outboxTracker: NDKOutboxTracker {
⋮----
/// Relay ranker for intelligent selection
var relayRanker: NDKRelayRanker {
⋮----
/// Relay selector for choosing optimal relays
var relaySelector: NDKRelaySelector {
⋮----
/// Publishing strategy for outbox model
var publishingStrategy: NDKPublishingStrategy {
⋮----
/// Fetching strategy for outbox model
var fetchingStrategy: NDKFetchingStrategy {
⋮----
// MARK: - Outbox Configuration
⋮----
// MARK: - Enhanced Publishing Methods
⋮----
/// Publish an event using the outbox model
⋮----
func publishWithOutbox(
⋮----
// Sign event if needed
⋮----
// Validate event
⋮----
// Store in cache if available
⋮----
let selection = await relaySelector.selectRelaysForPublishing(
⋮----
// Publish using outbox strategy
⋮----
/// Retry publishing failed events
func retryFailedPublishes(olderThan interval: TimeInterval = 300) async {
⋮----
let eventsToRetry = await cache.getEventsForRetry(olderThan: interval)
⋮----
let config = record.publishConfig.map { publishConfig in
⋮----
// MARK: - Enhanced Fetching Methods
⋮----
/// Fetch events using the outbox model
func fetchEventsWithOutbox(
⋮----
/// Subscribe to events using the outbox model
func subscribeWithOutbox(
⋮----
// MARK: - Relay Information Management
⋮----
/// Fetch and cache relay information for a user
func trackUser(_ pubkey: String) async throws {
⋮----
/// Manually set relay information for a user
func setRelaysForUser(
⋮----
/// Update relay health metrics
func updateRelayPerformance(
⋮----
// Update in cache if available
⋮----
let healthScore = await relayRanker.getRelayHealthScore(url)
let metrics = RelayHealthMetrics(
⋮----
// MARK: - Cleanup
⋮----
/// Clean up outbox resources
func cleanupOutbox() async {
// Clean up tracker
⋮----
// Clean up publishing strategy
⋮----
// Clean up cache
⋮----
/// NDK Outbox Configuration
public struct NDKOutboxConfig {
/// Relays to blacklist from outbox selection
public let blacklistedRelays: Set<String>
⋮----
/// Default publish configuration
public let defaultPublishConfig: OutboxPublishConfig
⋮----
/// Default fetch configuration
public let defaultFetchConfig: OutboxFetchConfig
⋮----
/// Default subscription configuration
public let defaultSubscriptionConfig: OutboxSubscriptionConfig
⋮----
/// Whether to automatically retry failed publishes
public let autoRetryFailedPublishes: Bool
⋮----
/// Interval for automatic retry
public let retryInterval: TimeInterval
⋮----
public init(
⋮----
public static let `default` = NDKOutboxConfig()
</file>

<file path="Sources/NDKSwift/Core/NDKProfileManager.swift">
/// Configuration for profile management
public struct NDKProfileConfig {
/// Maximum number of profiles to keep in memory cache
public var cacheSize: Int
⋮----
/// Time interval before cached profiles are considered stale (in seconds)
public var staleAfter: TimeInterval
⋮----
/// Whether to automatically batch profile requests
public var batchRequests: Bool
⋮----
/// Delay before executing batched requests (in seconds)
public var batchDelay: TimeInterval
⋮----
/// Maximum number of profiles to request in a single subscription
public var maxBatchSize: Int
⋮----
public init(
⋮----
staleAfter: TimeInterval = 3600, // 1 hour
⋮----
public static let `default` = NDKProfileConfig()
⋮----
/// Entry in the profile cache
private struct ProfileCacheEntry {
let profile: NDKUserProfile
let fetchedAt: Date
⋮----
func isStale(after interval: TimeInterval) -> Bool {
⋮----
/// Manager for efficient profile fetching with caching and batching
public actor NDKProfileManager {
private weak var ndk: NDK?
private let config: NDKProfileConfig
⋮----
/// In-memory LRU cache for profiles
private var profileCache: [PublicKey: ProfileCacheEntry] = [:]
private var cacheOrder: [PublicKey] = [] // For LRU tracking
⋮----
/// Pending profile requests waiting to be batched
private var pendingRequests: [PublicKey: [CheckedContinuation<NDKUserProfile?, Error>]] = [:]
⋮----
/// Timer task for batching
private var batchTask: Task<Void, Never>?
⋮----
public init(ndk: NDK, config: NDKProfileConfig = .default) {
⋮----
/// Fetch a single profile with caching and optional force refresh
public func fetchProfile(for pubkey: PublicKey, forceRefresh: Bool = false) async throws -> NDKUserProfile? {
// Check cache first
⋮----
// If batching is disabled or force refresh, fetch immediately
⋮----
// Add to pending requests for batching
⋮----
// Schedule batch processing
⋮----
/// Fetch multiple profiles efficiently
public func fetchProfiles(for pubkeys: [PublicKey], forceRefresh: Bool = false) async throws -> [PublicKey: NDKUserProfile] {
var results: [PublicKey: NDKUserProfile] = [:]
var toFetch: [PublicKey] = []
⋮----
// Check cache for each pubkey
⋮----
// Fetch remaining profiles
⋮----
let fetched = try await fetchProfilesBatch(toFetch)
⋮----
/// Clear the profile cache
public func clearCache() {
⋮----
/// Get cache statistics
public func getCacheStats() -> (size: Int, hitRate: Double) {
// This would need hit/miss tracking for accurate hit rate
⋮----
// MARK: - Private Methods
⋮----
private func checkCache(for pubkey: PublicKey) -> NDKUserProfile? {
⋮----
// Check if stale
⋮----
// Remove stale entry
⋮----
// Update LRU order
⋮----
private func updateCache(pubkey: PublicKey, profile: NDKUserProfile) {
// Remove old entry if exists
⋮----
// Add new entry
⋮----
// Enforce cache size limit
⋮----
private func updateCacheOrder(for pubkey: PublicKey) {
// Move to end (most recently used)
⋮----
private func fetchProfileImmediately(for pubkey: PublicKey) async throws -> NDKUserProfile? {
⋮----
let user = ndk.getUser(pubkey)
let profile = try await user.fetchProfile(forceRefresh: true)
⋮----
private func fetchProfilesBatch(_ pubkeys: [PublicKey]) async throws -> [PublicKey: NDKUserProfile] {
⋮----
// Split into batches if needed
let batches = pubkeys.chunked(into: config.maxBatchSize)
⋮----
// Create filter for metadata events
let filter = NDKFilter(
⋮----
// Fetch events
let events = try await ndk.fetchEvents(filters: [filter])
⋮----
// Process events
⋮----
// Update the user object if available
let user = ndk.getUser(event.pubkey)
⋮----
private func scheduleBatchProcessing() {
// Cancel existing task if any
⋮----
// Schedule new batch processing
⋮----
private func processPendingBatch() async {
⋮----
// Get all pending pubkeys
let pubkeys = Array(pendingRequests.keys)
let continuations = pendingRequests
⋮----
// Fetch all profiles in batch
let profiles = try await fetchProfilesBatch(pubkeys)
⋮----
// Resume all continuations
⋮----
let profile = profiles[pubkey]
⋮----
// Resume all continuations with error
⋮----
// MARK: - Array Extension for Chunking
⋮----
func chunked(into size: Int) -> [[Element]] {
</file>

<file path="Sources/NDKSwift/Models/Kinds/NDKCashuMintList.swift">
/// Represents a NIP-60 Cashu mint list event (kind 10019)
public struct NDKCashuMintList {
/// The underlying event
public var event: NDKEvent
⋮----
/// The NDK instance
public var ndk: NDK {
⋮----
/// Initialize a new mint list
public init(ndk: NDK) {
⋮----
/// Create from an existing event
public static func from(_ event: NDKEvent) -> NDKCashuMintList? {
⋮----
var mintList = NDKCashuMintList(ndk: event.ndk ?? NDK())
⋮----
/// Get mint URLs from the event
public var mints: [String] {
⋮----
/// Add a mint URL
public mutating func addMint(_ url: String) {
// Remove existing mint tag for this URL if any
⋮----
// Add new mint tag
⋮----
/// Remove a mint URL
public mutating func removeMint(_ url: String) {
⋮----
/// Get relay URLs for publishing nutzaps
public var relays: [String] {
// Look for relay tags
⋮----
/// Add a relay URL
public mutating func addRelay(_ url: String) {
// Remove existing relay tag for this URL if any
⋮----
// Add new relay tag
⋮----
/// Check if P2PK is supported
public var p2pk: Bool {
// Check for P2PK tag
⋮----
/// Set P2PK support
public mutating func setP2PK(_ supported: Bool) {
// Remove existing p2pk tag
⋮----
/// Sign the mint list
public mutating func sign() async throws {
</file>

<file path="Sources/NDKSwift/Models/Kinds/NDKContactList.swift">
/// Represents a contact entry in a contact list with optional metadata
public struct NDKContactEntry {
public let user: NDKUser
public let relayURL: String?
public let petname: String?
⋮----
public init(user: NDKUser, relayURL: String? = nil, petname: String? = nil) {
⋮----
public init(pubkey: String, relayURL: String? = nil, petname: String? = nil) {
⋮----
/// Convert to Tag representation
public func toTag() -> Tag {
var tag = ["p", user.pubkey]
⋮----
/// Create from a Tag
public static func from(tag: Tag) -> NDKContactEntry? {
⋮----
let pubkey = tag[1]
let relayURL = tag.count > 2 && !tag[2].isEmpty ? tag[2] : nil
let petname = tag.count > 3 && !tag[3].isEmpty ? tag[3] : nil
⋮----
/// Specialized list for managing contacts/follows (NIP-02, kind 3)
/// Provides contact management with petnames and relay hints
public class NDKContactList: NDKList {
/// Contact list kind (3)
public static let kind = 3
⋮----
/// Initialize a new contact list
override public convenience init(ndk: NDK? = nil) {
⋮----
/// Create an NDKContactList from an existing NDKEvent
public static func fromEvent(_ event: NDKEvent) -> NDKContactList {
let contactList = NDKContactList(ndk: event.ndk)
⋮----
/// All contact entries in this list
public var contacts: [NDKContactEntry] {
let contactTags = tags.filter { $0.count > 1 && $0[0] == "p" }
⋮----
/// All contact pubkeys
public var contactPubkeys: [String] {
⋮----
/// All contacts as NDKUser objects
public var contactUsers: [NDKUser] {
⋮----
let user = contact.user
⋮----
/// Number of contacts in this list
public var contactCount: Int {
⋮----
/// Set the complete list of contact entries
public func setContacts(_ entries: [NDKContactEntry]) {
// Remove all existing contact tags
⋮----
// Add new contact entries
⋮----
// Update timestamp
⋮----
/// Add a contact to this list
⋮----
public func addContact(_ contact: NDKContactEntry) -> NDKContactList {
// Check if contact already exists
⋮----
/// Add a contact by pubkey
⋮----
public func addContact(pubkey: String, relayURL: String? = nil, petname: String? = nil) -> NDKContactList {
let contact = NDKContactEntry(pubkey: pubkey, relayURL: relayURL, petname: petname)
⋮----
/// Add a contact by NDKUser
⋮----
public func addContact(user: NDKUser, relayURL: String? = nil, petname: String? = nil) -> NDKContactList {
let contact = NDKContactEntry(user: user, relayURL: relayURL, petname: petname)
⋮----
/// Remove a contact by pubkey
⋮----
public func removeContact(pubkey: String) -> NDKContactList {
⋮----
/// Remove a contact by NDKUser
⋮----
public func removeContact(user: NDKUser) -> NDKContactList {
⋮----
/// Check if following a specific pubkey
public func isFollowing(_ pubkey: String) -> Bool {
⋮----
/// Check if following a specific user
public func isFollowing(_ user: NDKUser) -> Bool {
⋮----
/// Get contact entry for a specific pubkey
public func contactEntry(for pubkey: String) -> NDKContactEntry? {
⋮----
/// Get contact entry for a specific user
public func contactEntry(for user: NDKUser) -> NDKContactEntry? {
⋮----
/// Get petname for a specific pubkey
public func petname(for pubkey: String) -> String? {
⋮----
/// Get petname for a specific user
public func petname(for user: NDKUser) -> String? {
⋮----
/// Update petname for an existing contact
⋮----
public func updatePetname(for pubkey: String, petname: String?) -> NDKContactList {
⋮----
let existingTag = tags[index]
let relayURL = existingTag.count > 2 ? existingTag[2] : ""
⋮----
var newTag = ["p", pubkey, relayURL]
⋮----
/// Update relay URL for an existing contact
⋮----
public func updateRelayURL(for pubkey: String, relayURL: String?) -> NDKContactList {
⋮----
let petname = existingTag.count > 3 ? existingTag[3] : ""
⋮----
var newTag = ["p", pubkey, relayURL ?? ""]
⋮----
/// Get contacts with petnames
public var contactsWithPetnames: [NDKContactEntry] {
⋮----
/// Get contacts with relay URLs
public var contactsWithRelayURLs: [NDKContactEntry] {
⋮----
/// Create a filter to fetch events from all contacts
public func createContactFilter(kinds: [Int] = [1], since: Timestamp? = nil, until: Timestamp? = nil, limit: Int? = nil) -> NDKFilter {
var filter = NDKFilter(authors: contactPubkeys, kinds: kinds)
⋮----
/// Merge another contact list into this one
⋮----
public func merge(with other: NDKContactList) -> NDKContactList {
⋮----
/// Create a contact list from an array of pubkeys
public static func from(pubkeys: [String], ndk: NDK? = nil) -> NDKContactList {
let contactList = NDKContactList(ndk: ndk)
⋮----
/// Create a contact list from an array of users
public static func from(users: [NDKUser], ndk: NDK? = nil) -> NDKContactList {
⋮----
// MARK: - Integration with NDK
⋮----
/// Fetch the contact list for a specific user
func fetchContactList(for user: NDKUser) async throws -> NDKContactList? {
let filter = NDKFilter(authors: [user.pubkey], kinds: [3], limit: 1)
let events = try await fetchEvents(filters: [filter])
⋮----
/// Fetch the contact list for the current user
func fetchContactList() async throws -> NDKContactList? {
⋮----
let pubkey = try await signer.pubkey
let currentUser = NDKUser(pubkey: pubkey)
⋮----
/// Publish a contact list
func publishContactList(_ contactList: NDKContactList) async throws {
⋮----
let event = contactList.toNDKEvent()
⋮----
/// Follow a user (add to contact list)
func follow(_ user: NDKUser) async throws {
let contactList = try await fetchContactList() ?? NDKContactList(ndk: self)
⋮----
/// Unfollow a user (remove from contact list)
func unfollow(_ user: NDKUser) async throws {
⋮----
/// Check if currently following a user
func isFollowing(_ user: NDKUser) async throws -> Bool {
⋮----
/// Fetch this user's contact list
⋮----
/// Get the list of users this user follows
func following() async throws -> [NDKUser] {
⋮----
/// Check if this user follows another user
func isFollowing(_ other: NDKUser) async throws -> Bool {
</file>

<file path="Sources/NDKSwift/Models/Kinds/NDKImage.swift">
/// NDKImage represents a Nostr image event (kind 20)
public struct NDKImage {
// MARK: - Static Properties
⋮----
/// The primary kind for image events
public static let kind: Kind = EventKind.image
⋮----
/// All supported kinds for this event type
public static let kinds: [Kind] = [EventKind.image]
⋮----
// MARK: - Properties
⋮----
/// The underlying event
public let event: NDKEvent
⋮----
/// Cached imeta tags for performance
private var _imetas: [NDKImetaTag]?
⋮----
// MARK: - Event Property Forwarding
⋮----
/// The event ID
public var id: EventID? {
⋮----
/// The public key of the event creator
public var pubkey: PublicKey {
⋮----
/// The timestamp when the event was created
public var createdAt: Timestamp {
⋮----
/// The event kind (always EventKind.image for NDKImage)
public var kind: Kind {
⋮----
/// The event content
public var content: String {
⋮----
/// The event tags
public var tags: [[String]] {
⋮----
/// The event signature
public var sig: String? {
⋮----
/// The associated NDK instance
public var ndk: NDK? {
⋮----
// MARK: - Initialization
⋮----
/// Initialize a new NDKImage event
public init(ndk: NDK? = nil, pubkey: PublicKey = "") {
⋮----
/// Create an NDKImage from an existing NDKEvent
public init(event: NDKEvent) {
⋮----
public static func from(event: NDKEvent) -> NDKImage {
⋮----
// MARK: - Validation
⋮----
/// Check if this image event is valid (has at least one imeta tag with a URL)
public var isValid: Bool {
⋮----
// MARK: - Imeta Tag Management
⋮----
/// Get all imeta tags from this image event
public var imetas: [NDKImetaTag] {
let imetaTags = event.tags
⋮----
/// Set imeta tags for this image event
public mutating func setImetas(_ newImetas: [NDKImetaTag]) {
// Remove all existing imeta tags
⋮----
// Add new imeta tags
⋮----
let tag = ImetaUtils.imetaTagToTag(imeta)
⋮----
// MARK: - Convenience Methods
⋮----
/// Add a single imeta tag
public mutating func addImeta(_ imeta: NDKImetaTag) {
⋮----
/// Get the primary image URL (from the first imeta tag)
public var primaryImageURL: String? {
⋮----
/// Get all image URLs
public var imageURLs: [String] {
⋮----
/// Get dimensions for the primary image
public var primaryImageDimensions: (width: Int, height: Int)? {
⋮----
let parts = dim.split(separator: "x")
⋮----
// MARK: - Convenience Tag Methods
⋮----
/// Add a tag to the image
public mutating func addTag(_ tag: [String]) {
⋮----
/// Get tags matching a specific tag name
public func tags(withName tagName: String) -> [[String]] {
⋮----
/// Get the first value of a tag with the given name
public func tagValue(_ tagName: String) -> String? {
</file>

<file path="Sources/NDKSwift/Models/Kinds/NDKList.swift">
/// Protocol for objects that can be stored in an NDKList
public protocol NDKListItem {
/// Convert this item to a Tag for storage in a list
⋮----
/// The reference value used to identify this item in a list
⋮----
/// Represents an item in a list with optional marking and position
public struct NDKListEntry {
public let item: NDKListItem
public let mark: String?
public let encrypted: Bool
public let position: ListPosition
⋮----
public init(item: NDKListItem, mark: String? = nil, encrypted: Bool = false, position: ListPosition = .bottom) {
⋮----
/// Position for adding items to a list
public enum ListPosition {
⋮----
/// Base class for all Nostr lists following NIP-51
/// Provides a unified interface for managing different types of lists
public class NDKList {
// MARK: - NDKEvent Properties
⋮----
/// Unique event ID (32-byte hash)
public var id: EventID?
⋮----
/// Public key of the event creator
public var pubkey: PublicKey = ""
⋮----
/// Unix timestamp when the event was created
public var createdAt: Timestamp = 0
⋮----
/// Event kind
public var kind: Kind = 0
⋮----
/// Event tags
public var tags: [Tag] = []
⋮----
/// Event content
public var content: String = ""
⋮----
/// Event signature
public var signature: Signature?
⋮----
/// Reference to NDK instance
public weak var ndk: NDK?
⋮----
/// Supported list kinds from NIP-51 and related NIPs
public static let supportedKinds: Set<Int> = [
3, // Contact list
10000, // Mute list
10001, // Pin list
10002, // Relay list
10003, // Bookmark list
10004, // Communities list
10005, // Public chats list
10006, // Blocked relays list
10007, // Search relays list
10015, // Interest list
10030, // User emoji list
30000, // Categorized people list
30001, // Categorized bookmark list
30002, // Relay list metadata
30063, // Blossom server list
⋮----
/// Initialize a new list
public init(ndk: NDK? = nil) {
⋮----
/// Initialize a new list with the specified kind
public convenience init(ndk: NDK? = nil, kind: Int) {
⋮----
/// The title of this list
public var title: String? {
⋮----
// First check for explicit title tag
⋮----
// Fall back to kind-specific defaults
⋮----
// Remove existing title/name tags
⋮----
// Add new title if provided
⋮----
/// Default title based on the list kind
private var defaultTitleForKind: String? {
⋮----
/// Description of this list
public var listDescription: String? {
⋮----
let descTag = tags.first { $0.count > 0 && $0[0] == "description" }
⋮----
/// Image URL for this list
public var image: String? {
⋮----
let imageTag = tags.first { $0.count > 0 && $0[0] == "image" }
⋮----
/// All public list items (non-encrypted tags)
public var publicItems: [Tag] {
⋮----
// Include standard list item tags but exclude metadata tags
⋮----
let tagType = tag[0]
⋮----
// Include other non-metadata tags
⋮----
/// Encrypted list items (stored in content as JSON)
private var encryptedItems: [Tag] {
⋮----
// Try to parse content as JSON array of tags
⋮----
let data = content.data(using: .utf8) ?? Data()
let tagArrays = try JSONSerialization.jsonObject(with: data) as? [[String]]
⋮----
// Tags are already in the correct format
let tagArrays = newValue
⋮----
let data = try JSONSerialization.data(withJSONObject: tagArrays)
⋮----
/// All items in this list (both public and encrypted)
public var allItems: [Tag] {
⋮----
/// Create an NDKList from an existing NDKEvent
public static func from(_ event: NDKEvent) -> NDKList {
let list = NDKList(ndk: event.ndk)
⋮----
/// Convert this list to an NDKEvent
public func toNDKEvent() -> NDKEvent {
let event = NDKEvent(
⋮----
/// Check if this list contains a specific item by reference
public func contains(_ reference: String) -> Bool {
⋮----
let tagValue = tag[1]
⋮----
/// Add an item to this list
⋮----
public func addItem(_ item: NDKListItem, mark: String? = nil, encrypted: Bool = false, position: ListPosition = .bottom) async throws -> NDKList {
// Check if item already exists
⋮----
var listTag = item.toListTag()
⋮----
// Add mark as additional info if provided
⋮----
// Add to encrypted items
var currentEncrypted = encryptedItems
⋮----
// Encrypt the content if we have a signer
⋮----
// Add to public tags
⋮----
// Insert after metadata tags
let metadataCount = tags.prefix { tag in
⋮----
// Update timestamp
⋮----
/// Remove an item from this list by index
⋮----
public func removeItem(at index: Int, encrypted: Bool) async throws -> NDKList {
⋮----
// Re-encrypt the content if we have a signer
⋮----
let publicItemTags = publicItems
⋮----
let tagToRemove = publicItemTags[index]
// Remove by comparing tag content since we can't use object identity
⋮----
/// Remove an item from this list by reference value
⋮----
public func removeItem(byReference reference: String) async throws -> NDKList {
// Remove from public tags
⋮----
// Remove from encrypted tags
let currentEncrypted = encryptedItems
let filteredEncrypted = currentEncrypted.filter { tag in
⋮----
/// Create filters to fetch the contents of this list
public func filtersForItems() -> [NDKFilter] {
var filters: [NDKFilter] = []
let items = allItems
⋮----
// Filter for events referenced by 'e' tags
let eventIds = items.compactMap { tag -> String? in
⋮----
// Filter for parameterized replaceable events referenced by 'a' tags
let aTagGroups = Dictionary(grouping: items.compactMap { tag -> (kind: Int, pubkey: String, dTag: String?)? in
⋮----
let parts = tag[1].split(separator: ":")
⋮----
let dTag = parts.count > 2 ? String(parts[2]) : nil
⋮----
let authors = items.map { $0.pubkey }
let filter = NDKFilter(authors: authors, kinds: [kind])
⋮----
// Add d-tag filter if we have specific d-tags
let dTags = items.compactMap { $0.dTag }
⋮----
// Note: This would need proper tag filter implementation
// filter.addTagFilter("d", values: Set(dTags))
⋮----
// Filter for profiles referenced by 'p' tags
let pubkeys = items.compactMap { tag -> String? in
⋮----
/// Encrypt the content using the provided signer
private func encrypt(_: NDKSigner) async throws {
⋮----
// Create JSON representation of encrypted items
let jsonData = try JSONSerialization.data(withJSONObject: encryptedItems)
let jsonString = String(data: jsonData, encoding: .utf8) ?? ""
⋮----
// For now, store as plain JSON - encryption would require NIP-04/44 implementation
⋮----
/// Decrypt the content using the provided signer
private func decrypt(_: NDKSigner) async throws {
⋮----
// For now, assume content is plain JSON - decryption would require NIP-04/44 implementation
// This is a placeholder for future encryption support
⋮----
/// Sign this list as an event
public func sign() async throws {
⋮----
let event = toNDKEvent()
⋮----
// Generate ID if not present
⋮----
// Sign the event
let signature = try await signer.sign(event)
⋮----
// Update our properties with signed values
⋮----
/// Publish this list
public func publish() async throws {
⋮----
// MARK: - NDKListItem Implementations
⋮----
public func toListTag() -> Tag {
⋮----
public var reference: String {
⋮----
// Use 'a' tag for parameterized replaceable events
let dTagElement = tags.first { $0.count > 0 && $0[0] == "d" }
let dTag = (dTagElement?.count ?? 0) > 1 ? dTagElement![1] : ""
let aTagValue = "\(kind):\(pubkey):\(dTag)"
⋮----
// Use 'e' tag for regular events
⋮----
/// Simple string-based list item for hashtags and other text content
public struct NDKStringListItem: NDKListItem {
public let tagType: String
public let value: String
⋮----
public init(tagType: String, value: String) {
⋮----
// MARK: - Convenience Extensions
⋮----
/// Add a hashtag to this list
func addHashtag(_ hashtag: String, mark: String? = nil, encrypted: Bool = false, position: ListPosition = .bottom) async throws {
let item = NDKStringListItem(tagType: "t", value: hashtag.hasPrefix("#") ? String(hashtag.dropFirst()) : hashtag)
⋮----
/// Add a URL to this list
func addURL(_ url: String, mark: String? = nil, encrypted: Bool = false, position: ListPosition = .bottom) async throws {
let item = NDKStringListItem(tagType: "r", value: url)
⋮----
/// Get all hashtags in this list
var hashtags: [String] {
⋮----
/// Get all URLs in this list
var urls: [String] {
⋮----
/// Get all user pubkeys in this list
var userPubkeys: [String] {
⋮----
/// Get all event IDs in this list
var eventIds: [String] {
</file>

<file path="Sources/NDKSwift/Models/Kinds/NDKNutzap.swift">
/// Cashu proof for NIP-61
public struct CashuProof: Codable {
public let id: String // Keyset id
public let amount: Int // Amount in Satoshis
public let secret: String // Initial secret
public let C: String // Unblinded signature
⋮----
public init(id: String, amount: Int, secret: String, C: String) {
⋮----
/// Represents a NIP-61 nutzap event
public struct NDKNutzap {
/// The underlying event
public var event: NDKEvent
⋮----
/// The NDK instance
public var ndk: NDK {
⋮----
/// Initialize a new nutzap
public init(ndk: NDK) {
⋮----
// Ensure we have an alt tag
⋮----
/// The Cashu proofs
public var proofs: [CashuProof] {
⋮----
// Try to get proofs from tags first (preferred format)
let proofTags = event.tags.filter { $0.first == "proof" }
⋮----
// Fallback to content (old format)
⋮----
// Remove old proof tags
⋮----
// Add new proof tags
⋮----
/// The comment for the nutzap
public var comment: String? {
⋮----
// Check for comment tag first
⋮----
// Fallback to content if it's not JSON
⋮----
/// The mint URL
public var mint: String? {
⋮----
/// The target event or user
public var target: NDKEventPointer? {
// Check for 'e' tag (event)
⋮----
// Check for 'p' tag (user)
⋮----
/// Set the target for the nutzap
public mutating func setTarget(_ target: NDKEventPointer) {
// Remove existing target tags
⋮----
// Add new target tag
⋮----
/// The recipient's pubkey
public var recipientPubkey: String? {
// For nutzaps, the recipient is always in a 'p' tag
⋮----
/// Set the recipient
public mutating func setRecipient(_ pubkey: String) {
⋮----
// If no target or target is different, add p tag
⋮----
/// The unit (always "sat" for nutzaps)
public var unit: String {
⋮----
/// Get P2PK data if present
public var p2pkData: String? {
⋮----
// Try to parse the secret
⋮----
let decoded = try JSONSerialization.jsonObject(with: secretData)
⋮----
// Check if it's an array with P2PK format
⋮----
// Check if it's a direct object with P2PK data
⋮----
// Secret is not P2PK formatted
⋮----
/// Total amount of the nutzap
public var totalAmount: Int {
⋮----
/// Create from an existing event
public static func from(_ event: NDKEvent) -> NDKNutzap? {
⋮----
var nutzap = NDKNutzap(ndk: event.ndk ?? NDK())
⋮----
// Validate that we have proofs
⋮----
/// Sign the nutzap
public mutating func sign() async throws {
⋮----
/// Publish the nutzap to specific relays
public func publish(on _: NDKRelaySet) async throws {
// Ensure the event is signed
var mutableSelf = self
⋮----
// TODO: Implement relay-specific publishing
// For now, use the standard publish method
⋮----
/// Event pointer for targets
public enum NDKEventPointer {
⋮----
var pubkey: String? {
⋮----
// Helper extension for safe array access
⋮----
subscript(safe index: Int) -> Element? {
</file>

<file path="Sources/NDKSwift/Models/Kinds/NDKRelayList.swift">
/// Relay access modes for relay list entries
public enum NDKRelayAccess: String, CaseIterable {
⋮----
public var marker: String? {
⋮----
/// Represents a relay entry in a relay list with access permissions
public struct NDKRelayListEntry {
public let relay: NDKRelay
public let access: Set<NDKRelayAccess>
⋮----
public init(relay: NDKRelay, access: Set<NDKRelayAccess> = [.read, .write]) {
⋮----
public init(url: String, access: Set<NDKRelayAccess> = [.read, .write]) {
⋮----
/// Whether this relay supports reading
public var canRead: Bool {
⋮----
/// Whether this relay supports writing
public var canWrite: Bool {
⋮----
/// Convert to Tag representation
public func toTag() -> Tag {
var tag = ["r", relay.url]
let accessMarkers = access.compactMap { $0.marker }
⋮----
/// Specialized list for managing user relay preferences (NIP-65, kind 10002)
/// Provides read/write relay separation and relay set integration
public class NDKRelayList: NDKList {
/// The kind for relay lists (NIP-65)
public static let kind: Kind = 10002
⋮----
/// Initialize a new relay list
override public convenience init(ndk: NDK? = nil) {
⋮----
/// Create an NDKRelayList from an existing NDKEvent
public static func fromEvent(_ event: NDKEvent) -> NDKRelayList {
let relayList = NDKRelayList(ndk: event.ndk)
⋮----
/// All relay entries in this list with their access permissions
public var relayEntries: [NDKRelayListEntry] {
let relayTags = tags.filter { $0.count > 0 && $0[0] == "r" }
⋮----
let url = tag[1]
⋮----
// Parse access markers from additional elements
var access: Set<NDKRelayAccess> = []
⋮----
// If no access markers specified, assume both read and write
⋮----
/// All relays that support reading
public var readRelays: [NDKRelay] {
⋮----
/// All relays that support writing
public var writeRelays: [NDKRelay] {
⋮----
/// All relay URLs in this list
public var relayURLs: [String] {
⋮----
/// Set the complete list of relay entries
public func setRelays(_ entries: [NDKRelayListEntry]) {
// Remove all existing relay tags
⋮----
// Add new relay entries
⋮----
// Update timestamp
⋮----
/// Add a relay with specified access permissions
⋮----
public func addRelay(_ url: String, access: Set<NDKRelayAccess> = [.read, .write]) -> NDKRelayList {
// Normalize the URL
let normalizedURL = URLNormalizer.tryNormalizeRelayUrl(url) ?? url
⋮----
// Check if relay already exists
⋮----
let entry = NDKRelayListEntry(url: normalizedURL, access: access)
⋮----
/// Add a relay for reading only
⋮----
public func addReadRelay(_ url: String) -> NDKRelayList {
⋮----
/// Add a relay for writing only
⋮----
public func addWriteRelay(_ url: String) -> NDKRelayList {
⋮----
/// Remove a relay by URL
⋮----
public func removeRelay(_ url: String) -> NDKRelayList {
⋮----
/// Update access permissions for an existing relay
⋮----
public func updateRelayAccess(_ url: String, access: Set<NDKRelayAccess>) -> NDKRelayList {
⋮----
// Find and update the relay tag
⋮----
var newTag = ["r", normalizedURL]
⋮----
/// Check if a relay is in this list
public func hasRelay(_ url: String) -> Bool {
⋮----
/// Get access permissions for a specific relay
public func accessFor(relay url: String) -> Set<NDKRelayAccess>? {
⋮----
/// Create a relay set from this relay list for use with NDK
public func toRelaySet() -> Set<NDKRelay> {
⋮----
/// Create read relay set
public func readRelaySet() -> Set<NDKRelay> {
⋮----
/// Create write relay set
public func writeRelaySet() -> Set<NDKRelay> {
⋮----
/// Merge another relay list into this one
⋮----
public func merge(with other: NDKRelayList) -> NDKRelayList {
⋮----
/// Create a relay list from a set of relays with default read/write access
public static func from(relays: [String], ndk: NDK? = nil) -> NDKRelayList {
let relayList = NDKRelayList(ndk: ndk)
⋮----
/// Create a relay list with separate read and write relays
public static func from(readRelays: [String], writeRelays: [String], ndk: NDK? = nil) -> NDKRelayList {
⋮----
// MARK: - Integration with NDK
⋮----
/// Fetch the relay list for a specific user
func fetchRelayList(for user: NDKUser) async throws -> NDKRelayList? {
let filter = NDKFilter(authors: [user.pubkey], kinds: [10002], limit: 1)
let events = try await fetchEvents(filters: [filter])
⋮----
/// Fetch the relay list for the current user
func fetchRelayList() async throws -> NDKRelayList? {
⋮----
let pubkey = try await signer.pubkey
let currentUser = NDKUser(pubkey: pubkey)
⋮----
/// Publish a relay list
func publishRelayList(_ relayList: NDKRelayList) async throws {
⋮----
let event = relayList.toNDKEvent()
⋮----
/// Fetch this user's relay list
</file>

<file path="Sources/NDKSwift/Outbox/LRUCache.swift">
/// A thread-safe LRU (Least Recently Used) cache implementation
actor LRUCache<Key: Hashable, Value> {
private class Node {
let key: Key
var value: Value
var prev: Node?
var next: Node?
var expiresAt: Date?
⋮----
init(key: Key, value: Value, ttl: TimeInterval?) {
⋮----
var isExpired: Bool {
⋮----
private let capacity: Int
private let defaultTTL: TimeInterval?
private var cache: [Key: Node] = [:]
private var head: Node?
private var tail: Node?
⋮----
init(capacity: Int, defaultTTL: TimeInterval? = nil) {
⋮----
/// Get a value from the cache
func get(_ key: Key) -> Value? {
⋮----
// Check if expired
⋮----
// Move to front (most recently used)
⋮----
/// Set a value in the cache
func set(_ key: Key, value: Value, ttl: TimeInterval? = nil) {
// Remove existing node if present
⋮----
// Create new node
let node = Node(key: key, value: value, ttl: ttl ?? defaultTTL)
⋮----
// Add to front
⋮----
// Evict if over capacity
⋮----
/// Remove a value from the cache
func remove(_ key: Key) {
⋮----
/// Clear all items from the cache
func clear() {
⋮----
/// Get all non-expired values
func allValues() -> [Value] {
let now = Date()
⋮----
/// Get all non-expired key-value pairs
func allItems() -> [(Key, Value)] {
⋮----
// MARK: - Private Methods
⋮----
private func addToFront(_ node: Node) {
⋮----
private func removeNode(_ node: Node) {
⋮----
private func moveToFront(_ node: Node) {
⋮----
cache[node.key] = node // Re-add to cache
⋮----
private func evictLRU() {
⋮----
/// Clean up expired entries
func cleanupExpired() {
⋮----
let expiredKeys = cache.compactMap { key, node -> Key? in
</file>

<file path="Sources/NDKSwift/Outbox/NDKEventExtensions.swift">
/// Extensions to NDKEvent for outbox model support
⋮----
/// Generate Proof of Work for this event
func generatePow(targetDifficulty: Int) async throws {
// Calculate the target based on difficulty
let targetHex = String(repeating: "0", count: targetDifficulty / 4)
let targetBits = targetDifficulty % 4
let targetChar: Character
⋮----
let fullTarget = targetHex + String(targetChar)
⋮----
// Add nonce tag if not present
var nonceTagIndex: Int?
⋮----
// Try different nonces until we find one that works
var nonce: UInt64 = 0
let maxAttempts: UInt64 = 10_000_000 // Prevent infinite loop
⋮----
// Update nonce in tags
⋮----
// Regenerate event ID
let newId = try generateID()
⋮----
// Check if it meets difficulty
⋮----
// Success! Update the event ID
⋮----
self.sig = nil // Clear signature as event changed
⋮----
// Yield periodically to avoid blocking
⋮----
/// Extract p tags (mentioned pubkeys)
var pTags: [String] {
⋮----
/// Extract e tags with optional recommended relay
var eTags: [(eventId: String, recommendedRelay: String?)] {
⋮----
let eventId = tag[1]
let recommendedRelay = tag.count > 2 ? tag[2] : nil
</file>

<file path="Sources/NDKSwift/Outbox/NDKFetchingStrategy.swift">
/// Manages fetching events using the outbox model with intelligent relay selection
public actor NDKFetchingStrategy {
private let ndk: NDK
private let selector: NDKRelaySelector
private let ranker: NDKRelayRanker
⋮----
/// Active fetch operations
private var activeFetches: [String: FetchOperation] = [:]
⋮----
/// Subscription management
private var activeSubscriptions: [String: OutboxSubscription] = [:]
⋮----
public init(ndk: NDK, selector: NDKRelaySelector, ranker: NDKRelayRanker) {
⋮----
/// Fetch events using outbox model
public func fetchEvents(
⋮----
let fetchId = UUID().uuidString
⋮----
// Select source relays
let selection = await selector.selectRelaysForFetching(
⋮----
// Create fetch operation
let operation = FetchOperation(
⋮----
// Execute fetch
⋮----
/// Subscribe to events using outbox model
public func subscribe(
⋮----
let subscriptionId = UUID().uuidString
⋮----
// Determine relay sets for each filter
var relaySelections: [RelaySelectionResult] = []
⋮----
// Combine relay selections
let allRelays = Set(relaySelections.flatMap { $0.relays })
⋮----
// Create outbox subscription
let subscription = OutboxSubscription(
⋮----
// Start subscriptions on selected relays
⋮----
/// Close a subscription
public func closeSubscription(_ subscriptionId: String) async {
⋮----
// Close all relay subscriptions
⋮----
/// Get active subscriptions
public func getActiveSubscriptions() -> [OutboxSubscription] {
⋮----
// MARK: - Private Methods
⋮----
private func executeFetch(operation: FetchOperation) async throws -> [NDKEvent] {
var collectedEvents: [String: NDKEvent] = [:] // Deduplicate by ID
var errors: [Error] = []
⋮----
// Create concurrent fetch tasks for each relay
⋮----
// Collect results
var successfulRelays = 0
⋮----
// Deduplicate events
⋮----
// Update relay performance
⋮----
// Check if we have enough successful relays
⋮----
// Could implement early termination here if desired
⋮----
// Check if we met minimum relay requirement
let successCount = operation.relayStatuses.values.filter {
⋮----
private func fetchFromRelay(
⋮----
// Get or connect to relay
⋮----
// Create subscription with timeout
let events = try await withTimeout(seconds: config.timeoutInterval) {
⋮----
private func startSubscription(_ subscription: OutboxSubscription) async throws {
⋮----
// Start subscriptions on each relay
⋮----
// Update status based on successful connections
let connectedCount = subscription.relaySubscriptions.count
⋮----
private func subscribeToRelay(
⋮----
// Create relay subscription through NDK
var options = NDKSubscriptionOptions()
⋮----
let relaySubscription = ndk.subscribe(
⋮----
// Handle events
⋮----
// Handle EOSE
⋮----
private func getOrConnectRelay(url: String) async -> NDKRelay? {
// First check if already connected
⋮----
// Try to connect
⋮----
private func withTimeout<T>(
⋮----
// MARK: - Supporting Types
⋮----
/// Configuration for outbox fetching
public struct OutboxFetchConfig {
public let selectionConfig: FetchingConfig
public let minSuccessfulRelays: Int
public let timeoutInterval: TimeInterval
public let deduplicateEvents: Bool
⋮----
public init(
⋮----
public static let `default` = OutboxFetchConfig()
⋮----
/// Configuration for outbox subscriptions
public struct OutboxSubscriptionConfig {
public let fetchConfig: OutboxFetchConfig
public let autoReconnect: Bool
public let reconnectDelay: TimeInterval
⋮----
public static let `default` = OutboxSubscriptionConfig()
⋮----
/// A fetch operation
private class FetchOperation {
let id: String
let filter: NDKFilter
let targetRelays: Set<String>
let config: OutboxFetchConfig
let selectionMethod: SelectionMethod
var relayStatuses: [String: FetchStatus] = [:]
⋮----
init(
⋮----
func updateRelayStatus(_ relay: String, status: FetchStatus) {
⋮----
/// An outbox subscription
public class OutboxSubscription {
public let id: String
public let filters: [NDKFilter]
public let targetRelays: Set<String>
public let config: OutboxSubscriptionConfig
public let eventHandler: (NDKEvent) -> Void
⋮----
public var status: SubscriptionStatus = .pending
public var relayStatuses: [String: SubscriptionRelayStatus] = [:]
public var relaySubscriptions: [String: NDKSubscription] = [:]
public var seenEventIds: Set<String> = []
public var eventCount: Int = 0
⋮----
func updateRelayStatus(_ relay: String, status: SubscriptionRelayStatus) {
⋮----
/// Fetch status for a relay
private enum FetchStatus {
⋮----
/// Subscription status
public enum SubscriptionStatus {
⋮----
/// Subscription relay status
public enum SubscriptionRelayStatus {
⋮----
case eose // End of stored events
⋮----
/// Fetch result
private enum FetchResult {
⋮----
/// Fetch errors
enum FetchError: LocalizedError {
⋮----
var errorDescription: String? {
</file>

<file path="Sources/NDKSwift/Outbox/NDKOutboxItem.swift">
/// Represents relay information for a specific user in the outbox model
public struct NDKOutboxItem: Codable, Equatable {
/// The user's public key
public let pubkey: String
⋮----
/// Relays the user reads from
public let readRelays: Set<RelayInfo>
⋮----
/// Relays the user writes to
public let writeRelays: Set<RelayInfo>
⋮----
/// When this information was last fetched
public let fetchedAt: Date
⋮----
/// Optional metadata about relay list source (kind 10002 vs kind 3)
public let source: RelayListSource
⋮----
public init(
⋮----
/// Get all unique relay URLs (both read and write)
public var allRelayURLs: Set<String> {
let readURLs = readRelays.map { $0.url }
let writeURLs = writeRelays.map { $0.url }
⋮----
/// Check if this item has expired based on TTL
public func isExpired(ttl: TimeInterval) -> Bool {
⋮----
/// Information about a specific relay
public struct RelayInfo: Codable, Hashable, Equatable {
/// The relay URL (normalized)
public let url: String
⋮----
/// Optional relay metadata
public let metadata: RelayMetadata?
⋮----
public init(url: String, metadata: RelayMetadata? = nil) {
⋮----
// Hashable conformance only considers URL
public func hash(into hasher: inout Hasher) {
⋮----
/// Metadata about a relay
public struct RelayMetadata: Codable, Equatable {
/// Relay health score (0-1)
public let score: Double?
⋮----
/// Last successful connection time
public let lastConnectedAt: Date?
⋮----
/// Average response time in milliseconds
public let avgResponseTime: Double?
⋮----
/// Number of failed attempts
public let failureCount: Int
⋮----
/// Whether authentication is required
public let authRequired: Bool
⋮----
/// Whether payment is required
public let paymentRequired: Bool
⋮----
/// Source of relay list information
public enum RelayListSource: String, Codable {
/// NIP-65 relay list (kind 10002)
⋮----
/// Contact list (kind 3)
⋮----
/// Manually configured
⋮----
/// Unknown source
</file>

<file path="Sources/NDKSwift/Outbox/NDKOutboxTracker.swift">
/// Tracks relay information for users to implement the outbox model
public actor NDKOutboxTracker {
/// Default TTL for cached relay information (2 minutes)
public static let defaultTTL: TimeInterval = 120
⋮----
/// Default cache capacity
public static let defaultCapacity = 1000
⋮----
private let ndk: NDK
private let cache: LRUCache<String, NDKOutboxItem>
private let blacklistedRelays: Set<String>
⋮----
/// Track pending fetches to avoid duplicate requests
private var pendingFetches: [String: Task<NDKOutboxItem?, Error>] = [:]
⋮----
public init(
⋮----
/// Get relay information for a user
public func getRelaysFor(
⋮----
// Check cache first
⋮----
// Check if there's already a pending fetch
⋮----
let result = try await pendingTask.value
⋮----
// Create new fetch task
let fetchTask = Task<NDKOutboxItem?, Error> {
⋮----
let item = try await fetchRelayList(for: pubkey)
⋮----
let result = try await fetchTask.value
⋮----
/// Get relay information synchronously from cache only
public func getRelaysSyncFor(
⋮----
/// Track a user's relay information
public func track(
⋮----
let readRelayInfos = readRelays
⋮----
let writeRelayInfos = writeRelays
⋮----
let item = NDKOutboxItem(
⋮----
/// Update relay metadata (e.g., health scores)
public func updateRelayMetadata(
⋮----
// Get all items that contain this relay
let allItems = await cache.allItems()
⋮----
var updated = false
⋮----
let updatedReadRelays = item.readRelays.map { relay -> RelayInfo in
⋮----
let updatedWriteRelays = item.writeRelays.map { relay -> RelayInfo in
⋮----
let updatedItem = NDKOutboxItem(
⋮----
/// Clear the cache
public func clear() async {
⋮----
/// Clean up expired entries
public func cleanupExpired() async {
⋮----
// MARK: - Private Methods
⋮----
private func fetchRelayList(for pubkey: String) async throws -> NDKOutboxItem? {
// First try NIP-65 (kind 10002)
⋮----
// Fallback to contact list (kind 3)
⋮----
let filter = NDKFilter(
⋮----
let eventSet = try await ndk.fetchEvents(filters: [filter])
let events = Array(eventSet).sorted { $0.createdAt > $1.createdAt }
⋮----
let relayList = NDKRelayList.fromEvent(latestEvent)
⋮----
let readRelayUrls = Set(relayList.readRelays.map { $0.url })
let readRelays = readRelayUrls
⋮----
let writeRelayUrls = Set(relayList.writeRelays.map { $0.url })
let writeRelays = writeRelayUrls
⋮----
// Find relays that support both read and write
let bothRelayUrls = readRelayUrls.intersection(writeRelayUrls)
let bothRelays = bothRelayUrls
⋮----
private func fetchContactListRelays(for pubkey: String) async throws -> NDKOutboxItem? {
⋮----
let contactList = NDKContactList.fromEvent(latestEvent)
⋮----
// Extract relay URLs from contact entries
let relayUrls = Set(contactList.contacts.compactMap { $0.relayURL })
let relays = relayUrls
⋮----
// For contact lists, use same relays for both read and write
⋮----
private func filterByType(_ item: NDKOutboxItem, type: RelayListType) -> NDKOutboxItem {
⋮----
/// Type of relay list to fetch
public enum RelayListType {
</file>

<file path="Sources/NDKSwift/Outbox/NDKRelayPoolExtensions.swift">
/// Extensions to NDKRelayPool for outbox model support
⋮----
/// Get relay by URL
func relay(for url: String) -> NDKRelay? {
let normalizedUrl = URLNormalizer.tryNormalizeRelayUrl(url) ?? url
⋮----
/// Add a relay and optionally connect to it
⋮----
func addRelay(url: String) async -> NDKRelay? {
let relay = addRelay(url)
⋮----
// Try to connect
⋮----
// Connection failed, but relay is still added
⋮----
/// Get permanent and connected relays
func permanentAndConnectedRelays() -> [NDKRelay] {
// For now, return all connected relays
// In the future, could distinguish between permanent and temporary relays
⋮----
/// Extensions to NDKRelay for outbox model support
⋮----
/// Publish an event and wait for response
func publish(_ event: NDKEvent) async throws -> (success: Bool, message: String?) {
// Send the event
let message = NostrMessage.event(subscriptionId: nil, event: event)
⋮----
// Wait for OK response (this would need proper implementation)
// For now, return success
// In a real implementation, would need to wait for ["OK", event.id, success, message]
⋮----
/// Fetch events with a filter
func fetchEvents(filter _: NDKFilter) async throws -> [NDKEvent] {
// This would need proper implementation with subscription handling
// For now, return empty array
⋮----
/// Subscribe to events on this relay
func subscribe(
⋮----
// Create subscription with this specific relay
var options = NDKSubscriptionOptions()
⋮----
let subscription = NDKSubscription(
⋮----
// Add event handler using onEvent method
</file>

<file path="Sources/NDKSwift/Outbox/NDKRelayRanker.swift">
/// Ranks relays based on various criteria for optimal selection
public actor NDKRelayRanker {
private let ndk: NDK
private let tracker: NDKOutboxTracker
⋮----
/// Cache of relay scores
private var relayScores: [String: RelayScore] = [:]
⋮----
public init(ndk: NDK, tracker: NDKOutboxTracker) {
⋮----
/// Get top relays for a set of authors
public func getTopRelaysForAuthors(
⋮----
// Count how many authors use each relay
var relayAuthorCount: [String: Int] = [:]
⋮----
// Sort by author count and apply limit
let sorted = relayAuthorCount.sorted { $0.value > $1.value }
⋮----
/// Rank relays for optimal selection
public func rankRelays(
⋮----
var rankedRelays: [RankedRelay] = []
⋮----
// Get connected relays for preferential treatment
let connectedRelayURLs = await ndk.relayPool.connectedRelays().map { $0.url }
let connectedSet = Set(connectedRelayURLs)
⋮----
let score = await calculateRelayScore(
⋮----
// Sort by score descending
⋮----
/// Update relay score based on performance
public func updateRelayPerformance(
⋮----
var score = relayScores[relayURL] ?? RelayScore()
⋮----
/// Get relay health score (0-1)
public func getRelayHealthScore(_ relayURL: String) -> Double {
guard let score = relayScores[relayURL] else { return 0.5 } // Default neutral score
⋮----
let total = score.successCount + score.failureCount
⋮----
// Calculate success rate
let successRate = Double(score.successCount) / Double(total)
⋮----
// Factor in recency (decay older scores)
let ageInHours = Date().timeIntervalSince(score.lastUpdated) / 3600
let recencyFactor = max(0.5, 1.0 - (ageInHours / 168)) // Decay over a week
⋮----
// MARK: - Private Methods
⋮----
private func calculateRelayScore(
⋮----
var score = 0.0
⋮----
// Connection status bonus
⋮----
// Health score component
let healthScore = getRelayHealthScore(relayURL)
⋮----
// Author coverage component
var authorCoverage = 0
⋮----
let coverageRatio = pubkeys.isEmpty ? 0 : Double(authorCoverage) / Double(pubkeys.count)
⋮----
// Response time component
⋮----
let avgResponseTime = relayScore.totalResponseTime / Double(relayScore.successCount)
// Lower response time = higher score (capped at 1.0)
let responseScore = max(0, 1.0 - (avgResponseTime / preferences.maxAcceptableResponseTime))
⋮----
/// Preferences for relay ranking
public struct RelayPreferences {
/// Bonus score for already connected relays
public let connectionBonus: Double
⋮----
/// Weight for relay health score
public let healthWeight: Double
⋮----
/// Weight for author coverage
public let coverageWeight: Double
⋮----
/// Weight for response time
public let responseTimeWeight: Double
⋮----
/// Maximum acceptable response time in seconds
public let maxAcceptableResponseTime: TimeInterval
⋮----
public init(
⋮----
public static let `default` = RelayPreferences()
⋮----
/// A relay with its calculated score
public struct RankedRelay {
public let url: String
public let score: Double
⋮----
/// Internal relay score tracking
private struct RelayScore {
var successCount: Int = 0
var failureCount: Int = 0
var totalResponseTime: TimeInterval = 0
var lastUpdated: Date = .init()
</file>

<file path="Sources/NDKSwift/Signers/NDKPrivateKeySigner.swift">
/// A signer that uses a private key directly
public final class NDKPrivateKeySigner: NDKSigner {
private let privateKey: PrivateKey
private let _pubkey: PublicKey
private var isReady = true
⋮----
/// Initialize with a private key
public init(privateKey: PrivateKey) throws {
⋮----
/// Initialize with an nsec string
public convenience init(nsec: String) throws {
let privateKey = try Bech32.privateKey(from: nsec)
⋮----
/// Generate a new signer with a random private key
public static func generate() throws -> NDKPrivateKeySigner {
let privateKey = Crypto.generatePrivateKey()
⋮----
// MARK: - NDKSigner Protocol
⋮----
public var pubkey: PublicKey {
⋮----
public func sign(_ event: NDKEvent) async throws -> Signature {
// Ensure event has an ID
⋮----
public func blockUntilReady() async throws {
// Private key signer is always ready
⋮----
public func encryptionEnabled() async -> [NDKEncryptionScheme] {
⋮----
public func encrypt(recipient: NDKUser, value: String, scheme: NDKEncryptionScheme) async throws -> String {
⋮----
public func decrypt(sender: NDKUser, value: String, scheme: NDKEncryptionScheme) async throws -> String {
⋮----
// MARK: - Utilities
⋮----
/// Get the private key in nsec format
public var nsec: String {
⋮----
/// Get the public key in npub format
public var npub: String {
⋮----
/// Get the private key (for testing purposes)
public var privateKeyValue: PrivateKey {
⋮----
/// Serialize the signer to a payload string
public func toPayload() -> String {
let payload: [String: Any] = [
⋮----
let data = try! JSONSerialization.data(withJSONObject: payload)
</file>

<file path="Sources/NDKSwift/Signers/NDKSigner.swift">
/// Protocol for signing Nostr events
public protocol NDKSigner {
/// The public key associated with this signer
⋮----
/// Sign an event
⋮----
/// Sign an event in place (mutating)
⋮----
/// Block until the signer is ready (e.g., user has unlocked it)
⋮----
/// Get the user associated with this signer
⋮----
/// Get relays recommended by this signer (optional)
⋮----
/// Check which encryption schemes are supported
⋮----
/// Encrypt a message
⋮----
/// Decrypt a message
⋮----
/// Default implementations
⋮----
func relays(ndk _: NDK?) async -> [NDKRelay] {
⋮----
func encryptionEnabled() async -> [NDKEncryptionScheme] {
⋮----
func user() async throws -> NDKUser {
let pubkey = try await self.pubkey
⋮----
func sign(event: inout NDKEvent) async throws {
let signature = try await sign(event)
⋮----
func blockUntilReady() async throws {
// Default implementation does nothing
⋮----
/// Encryption schemes supported by signers
public enum NDKEncryptionScheme: String, CaseIterable {
</file>

<file path="Sources/NDKSwift/Subscription/NDKSubscriptionTracker.swift">
/// Tracks subscription metrics and history for debugging and monitoring
public actor NDKSubscriptionTracker {
// MARK: - Properties
⋮----
/// Active subscription details keyed by subscription ID
private var activeSubscriptions: [String: NDKSubscriptionDetail] = [:]
⋮----
/// Closed subscription history (limited by maxClosedSubscriptions)
private var closedSubscriptions: [NDKClosedSubscription] = []
⋮----
/// Maximum number of closed subscriptions to remember
private let maxClosedSubscriptions: Int
⋮----
/// Whether to track closed subscriptions
private let trackClosedSubscriptions: Bool
⋮----
/// Cache for global statistics to avoid recalculation
private var cachedStatistics: NDKSubscriptionStatistics?
⋮----
// MARK: - Initialization
⋮----
public init(trackClosedSubscriptions: Bool = false, maxClosedSubscriptions: Int = 100) {
⋮----
// MARK: - Subscription Lifecycle
⋮----
/// Registers a new subscription for tracking
public func trackSubscription(
⋮----
let detail = NDKSubscriptionDetail(
⋮----
/// Records that a subscription has been sent to a specific relay
public func trackSubscriptionSentToRelay(
⋮----
let relayMetrics = NDKRelaySubscriptionMetrics(
⋮----
/// Records that an event was received for a subscription from a specific relay
public func trackEventReceived(
⋮----
// Update relay-specific metrics
⋮----
// Update overall metrics
⋮----
/// Records that EOSE was received from a relay
public func trackEoseReceived(subscriptionId: String, relayUrl: String) {
⋮----
/// Marks a subscription as closed
public func closeSubscription(_ subscriptionId: String) {
⋮----
let closedSub = NDKClosedSubscription(detail: detail)
⋮----
// Maintain max history size
⋮----
// MARK: - Query Methods
⋮----
/// Returns the current number of active subscriptions
public func activeSubscriptionCount() -> Int {
⋮----
/// Returns the total number of unique events received across all active subscriptions
public func totalUniqueEventsReceived() -> Int {
⋮----
/// Returns detailed information about a specific subscription
public func getSubscriptionDetail(_ subscriptionId: String) -> NDKSubscriptionDetail? {
⋮----
/// Returns all active subscription details
public func getAllActiveSubscriptions() -> [NDKSubscriptionDetail] {
⋮----
/// Returns metrics for a specific subscription
public func getSubscriptionMetrics(_ subscriptionId: String) -> NDKSubscriptionMetrics? {
⋮----
/// Returns relay-specific metrics for a subscription
public func getRelayMetrics(
⋮----
/// Returns all relay metrics for a subscription
public func getAllRelayMetrics(
⋮----
/// Returns the closed subscription history
public func getClosedSubscriptions() -> [NDKClosedSubscription] {
⋮----
/// Returns global subscription statistics
public func getStatistics() -> NDKSubscriptionStatistics {
⋮----
var stats = NDKSubscriptionStatistics()
⋮----
// Active subscriptions
⋮----
// Total subscriptions (active + closed)
⋮----
// Events from active subscriptions
let activeEvents = activeSubscriptions.values.reduce((unique: 0, total: 0)) { result, detail in
⋮----
// Events from closed subscriptions
let closedEvents = closedSubscriptions.reduce((unique: 0, total: 0)) { result, closed in
⋮----
// MARK: - Utility Methods
⋮----
/// Clears the closed subscription history
public func clearClosedSubscriptionHistory() {
⋮----
/// Exports all tracking data for debugging
public func exportTrackingData() -> [String: Any] {
⋮----
// MARK: - Private Methods
⋮----
private func invalidateStatisticsCache() {
</file>

<file path="Sources/NDKSwift/Subscription/NDKSubscriptionTrackingTypes.swift">
// MARK: - Subscription Metrics
⋮----
/// Overall metrics for a subscription across all relays
public struct NDKSubscriptionMetrics {
/// Unique identifier for the subscription
public let subscriptionId: String
⋮----
/// Total number of unique events received across all relays
public var totalUniqueEvents: Int
⋮----
/// Total number of events received (including duplicates)
public var totalEvents: Int
⋮----
/// Number of relays this subscription is active on
public var activeRelayCount: Int
⋮----
/// Timestamp when the subscription was started
public let startTime: Date
⋮----
/// Timestamp when the subscription was closed (nil if still active)
public var endTime: Date?
⋮----
/// Duration of the subscription in seconds (nil if still active)
public var duration: TimeInterval? {
⋮----
/// Whether the subscription is currently active
public var isActive: Bool {
⋮----
public init(subscriptionId: String, startTime: Date = Date()) {
⋮----
// MARK: - Relay-Level Subscription Tracking
⋮----
/// Tracks subscription details at the relay level
public struct NDKRelaySubscriptionMetrics {
/// The relay URL
public let relayUrl: String
⋮----
/// The actual filter sent to this relay (may differ from original due to optimization)
public let appliedFilter: NDKFilter
⋮----
/// Number of events received from this relay for this subscription
public var eventsReceived: Int
⋮----
/// Whether EOSE has been received from this relay
public var eoseReceived: Bool
⋮----
/// Timestamp when the subscription was sent to this relay
public let subscriptionTime: Date
⋮----
/// Timestamp when EOSE was received (nil if not received)
public var eoseTime: Date?
⋮----
/// Time to receive EOSE in seconds (nil if not received)
public var timeToEose: TimeInterval? {
⋮----
public init(relayUrl: String, appliedFilter: NDKFilter, subscriptionTime: Date = Date()) {
⋮----
// MARK: - Subscription Detail
⋮----
/// Complete details for a subscription including relay-level metrics
public struct NDKSubscriptionDetail {
/// The subscription ID
⋮----
/// The original filter requested by the user
public let originalFilter: NDKFilter
⋮----
/// Overall metrics for the subscription
public var metrics: NDKSubscriptionMetrics
⋮----
/// Relay-specific metrics keyed by relay URL
public var relayMetrics: [String: NDKRelaySubscriptionMetrics]
⋮----
/// List of unique relay URLs this subscription was sent to
public var relayUrls: [String] {
⋮----
public init(subscriptionId: String, originalFilter: NDKFilter) {
⋮----
// MARK: - Closed Subscription History
⋮----
/// Represents a completed subscription for historical tracking
public struct NDKClosedSubscription {
⋮----
/// The filter that was used
public let filter: NDKFilter
⋮----
/// Relays the subscription was sent to
public let relays: [String]
⋮----
/// Number of unique events received
public let uniqueEventCount: Int
⋮----
public let totalEventCount: Int
⋮----
/// Duration of the subscription in seconds
public let duration: TimeInterval
⋮----
/// When the subscription was started
⋮----
/// When the subscription was closed
public let endTime: Date
⋮----
/// Average events per second
public var eventsPerSecond: Double {
⋮----
public init(detail: NDKSubscriptionDetail) {
⋮----
// MARK: - Global Subscription Statistics
⋮----
/// Overall statistics for all subscriptions in the NDK instance
public struct NDKSubscriptionStatistics {
/// Number of currently active subscriptions
public var activeSubscriptions: Int
⋮----
/// Total number of subscriptions created (active + closed)
public var totalSubscriptions: Int
⋮----
/// Total unique events received across all subscriptions
⋮----
/// Total events received (including duplicates)
⋮----
/// Number of closed subscriptions being tracked
public var closedSubscriptionsTracked: Int
⋮----
/// Average events per subscription
public var averageEventsPerSubscription: Double {
⋮----
public init() {
</file>

<file path="Sources/NDKSwift/Utils/ContentTagger.swift">
/// Content tagging result
public struct ContentTag {
public let tags: [Tag]
public let content: String
⋮----
public init(tags: [Tag], content: String) {
⋮----
/// Decoded Nostr entity information
public struct DecodedNostrEntity {
public let type: String
public let eventId: String?
public let pubkey: String?
public let relays: [String]?
public let kind: Int?
public let identifier: String?
⋮----
/// Content tagging utilities for NDK Swift
public enum ContentTagger {
/// Generate hashtags from content
public static func generateHashtags(from content: String) -> [String] {
// Regex pattern for hashtags: #word (no special characters except underscore and hyphen)
let hashtagRegex = #"(?<=\s|^)(#[^\s!@#$%^&*()=+./,\[{\]};:'"?><]+)"#
⋮----
let matches = regex.matches(in: content, options: [], range: NSRange(location: 0, length: content.utf16.count))
var hashtags: [String] = []
var seenHashtags = Set<String>()
⋮----
let hashtag = String(content[range])
let tag = String(hashtag.dropFirst()) // Remove the # symbol
let normalizedTag = tag.lowercased()
⋮----
// Only add the first occurrence of each hashtag (case-insensitive)
⋮----
/// Decode Nostr entity from bech32 string
public static func decodeNostrEntity(_ entity: String) throws -> DecodedNostrEntity {
⋮----
let pubkey = Data(data).hexString
⋮----
let eventId = Data(data).hexString
⋮----
let decoded = try decodeTLV(data)
⋮----
let pubkey = Data(pubkeyData).hexString
let relays = decoded[1]?.compactMap { String(data: Data($0), encoding: .utf8) } ?? []
⋮----
let eventId = Data(eventIdData).hexString
⋮----
let pubkey = decoded[2]?.first.map { Data($0).hexString }
let kind = decoded[3]?.first.map { kindFromBytes($0) }
⋮----
let identifier = String(data: Data(identifierData), encoding: .utf8) ?? ""
⋮----
let kind = kindFromBytes(kindData)
⋮----
let eventId = "\(kind):\(pubkey):\(identifier)"
⋮----
/// Generate content tags from text content
public static func generateContentTags(from content: String, existingTags: [Tag] = []) -> ContentTag {
var tags = existingTags
var modifiedContent = content
⋮----
// Regex to match Nostr entities: @npub, @nprofile, nostr:npub, nostr:nprofile, etc.
let nostrRegex = #"(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+"#
⋮----
// If regex fails, just add hashtags
let hashtags = generateHashtags(from: content)
let newTags = hashtags.map { ["t", $0] }
⋮----
// Process matches in reverse order to maintain string indices
⋮----
let fullMatch = String(content[range])
⋮----
// Extract the entity part (after @ or nostr:)
let components = fullMatch.components(separatedBy: CharacterSet(charactersIn: "@:"))
⋮----
let decoded = try decodeNostrEntity(entity)
var newTag: Tag?
⋮----
let relay = decoded.relays?.first ?? ""
⋮----
// Also add p tag for author if available
⋮----
// Also add p tag for author
⋮----
// Replace the match with normalized nostr: format
⋮----
// If decoding fails, leave the original text
⋮----
// Add hashtag tags
let hashtags = generateHashtags(from: modifiedContent)
let hashtagTags = hashtags.map { ["t", $0] }
⋮----
/// Add tag if it doesn't already exist
private static func addTagIfNew(_ tag: Tag, to tags: inout [Tag]) {
// Check if a similar tag already exists
let exists = tags.contains { existingTag in
// For 'p' and 'q' tags, check if the second element (pubkey/eventId) matches
⋮----
// For other tags, check exact match
⋮----
/// Merge two tag arrays, removing duplicates and preferring more detailed tags
public static func mergeTags(_ tags1: [Tag], _ tags2: [Tag]) -> [Tag] {
var tagMap: [String: Tag] = [:]
⋮----
// Function to generate a key for the map
func generateKey(_ tag: Tag) -> String {
⋮----
// Function to check if one tag contains another
func isContained(_ smaller: Tag, _ larger: Tag) -> Bool {
⋮----
// Process all tags
let allTags = tags1 + tags2
⋮----
var shouldAdd = true
var keyToRemove: String?
⋮----
// Check against existing tags
⋮----
// Replace with the longer or equal-length tag
⋮----
/// Decode TLV (Type-Length-Value) encoded data
private static func decodeTLV(_ data: [UInt8]) throws -> [UInt8: [[UInt8]]] {
var result: [UInt8: [[UInt8]]] = [:]
var index = 0
⋮----
let type = data[index]
let length = Int(data[index + 1])
⋮----
let value = Array(data[index ..< index + length])
⋮----
/// Convert bytes to kind integer
private static func kindFromBytes(_ bytes: [UInt8]) -> Int {
</file>

<file path="Sources/NDKSwift/Utils/DataExtensions.swift">
// MARK: - Data extensions for hex conversion
⋮----
/// Initialize Data from hex string
init?(hexString: String) {
let hex = hexString.trimmingCharacters(in: .whitespacesAndNewlines)
⋮----
var data = Data(capacity: hex.count / 2)
var index = hex.startIndex
⋮----
let nextIndex = hex.index(index, offsetBy: 2)
⋮----
/// Convert Data to hex string
var hexString: String {
⋮----
// Extension for Foundation.Data (from CryptoSwift)
⋮----
func toHexString() -> String {
</file>

<file path="Sources/NDKSwift/Utils/FileManagerExtensions.swift">
// MARK: - FileManager Extensions for Codable Operations
⋮----
/// Loads a Codable object from a file
/// - Parameters:
///   - type: The type to decode
///   - fileURL: The URL of the file to read
/// - Returns: The decoded object
func loadCodable<T: Codable>(_ type: T.Type, from fileURL: URL) throws -> T {
let data = try Data(contentsOf: fileURL)
⋮----
/// Saves a Codable object to a file
⋮----
///   - object: The object to encode and save
///   - fileURL: The URL where the file should be saved
func saveCodable<T: Codable>(_ object: T, to fileURL: URL) throws {
let data = try JSONCoding.encode(object)
⋮----
/// Loads all Codable objects from a directory
⋮----
///   - directoryURL: The directory to scan
///   - matchingExtension: The file extension to match (default: "json")
/// - Returns: An array of decoded objects
func loadAllCodable<T: Codable>(
⋮----
/// Loads all Codable objects from a directory with their filenames
⋮----
/// - Returns: A dictionary mapping filenames (without extension) to decoded objects
func loadAllCodableWithFilenames<T: Codable>(
⋮----
var result: [String: T] = [:]
⋮----
let filename = fileURL.deletingPathExtension().lastPathComponent
</file>

<file path="Sources/NDKSwift/Utils/ImetaUtils.swift">
/// Utility functions for handling imeta tags
public enum ImetaUtils {
/// Maps a tag array to an NDKImetaTag structure
/// Supports both single-value format: ["imeta", "url https://... alt text"]
/// And multi-value format: ["imeta", "url https://...", "alt text", ...]
public static func mapImetaTag(_ tag: Tag) -> NDKImetaTag? {
⋮----
var imeta = NDKImetaTag()
⋮----
// Single value format: ["imeta", "url https://... alt text"]
let parts = tag[1].split(separator: " ", maxSplits: 1)
⋮----
let field = String(parts[0])
let value = String(parts[1])
⋮----
// Multi-value format: ["imeta", "url https://...", "alt text", ...]
⋮----
let parts = tag[i].split(separator: " ", maxSplits: 1)
⋮----
/// Converts an NDKImetaTag to a tag array format
public static func imetaTagToTag(_ imeta: NDKImetaTag) -> Tag {
var components = ["imeta"]
⋮----
// Handle fallback array
⋮----
// Handle additional fields
⋮----
// MARK: - Private Helpers
⋮----
private static func applyFieldValue(to imeta: inout NDKImetaTag, field: String, value: String) {
</file>

<file path="Sources/NDKSwift/Utils/URLNormalizer.swift">
/// Utility for normalizing relay URLs according to Nostr conventions
public enum URLNormalizer {
/// Normalizes a relay URL by ensuring proper format and consistency
/// - Parameter url: The URL string to normalize
/// - Returns: A normalized URL string, or nil if the URL is invalid
public static func tryNormalizeRelayUrl(_ url: String) -> String? {
⋮----
/// - Returns: A normalized URL string
/// - Throws: URLNormalizationError if the URL cannot be normalized
public static func normalizeRelayUrl(_ url: String) throws -> String {
var normalized = url.trimmingCharacters(in: .whitespacesAndNewlines)
⋮----
// Check for obviously invalid URLs
⋮----
// Ensure proper protocol
⋮----
// Default to wss:// for security
⋮----
// Parse URL to ensure validity and perform normalization
⋮----
// Convert scheme and host to lowercase
⋮----
// Remove authentication (username/password)
⋮----
// Remove fragment (hash)
⋮----
// Remove www. prefix from hostname if present
⋮----
// Remove default ports
⋮----
// Reconstruct the URL ensuring proper formatting
⋮----
var normalizedURL = normalizedComponents.absoluteString
⋮----
// Handle query parameters - ensure the slash comes before the query
⋮----
let beforeQuery = String(normalizedURL[..<queryRange.lowerBound])
let queryAndAfter = String(normalizedURL[queryRange.lowerBound...])
⋮----
// No query parameters, just ensure trailing slash
⋮----
/// Normalizes an array of relay URLs, removing duplicates
/// - Parameter urls: An array of URL strings to normalize
/// - Returns: An array of normalized, unique URL strings
public static func normalize(_ urls: [String]) -> [String] {
var normalized = Set<String>()
⋮----
/// Errors that can occur during URL normalization
public enum URLNormalizationError: LocalizedError {
⋮----
public var errorDescription: String? {
</file>

<file path="Sources/NDKSwift/Wallet/NDKCashuWallet.swift">
/// Represents a NIP-60 Cashu wallet
public class NDKCashuWallet: NDKWallet {
private let ndk: NDK
private let walletId: String
⋮----
/// Mint URLs this wallet uses
public private(set) var mints: Set<String> = []
⋮----
/// Current balance in satoshis
public private(set) var balance: Int64 = 0
⋮----
public init(ndk: NDK, walletId: String = UUID().uuidString) {
⋮----
// MARK: - NDKWallet Protocol
⋮----
public func pay(_ request: NDKPaymentRequest) async throws -> NDKPaymentConfirmation {
// Check balance
⋮----
// Get recipient's mint preferences
let recipientMints = try await getRecipientMints(request.recipient)
⋮----
// Find a common mint
let commonMints = mints.intersection(recipientMints)
⋮----
// Create nutzap
var nutzap = NDKNutzap(ndk: ndk)
⋮----
// In a real implementation, this would:
// 1. Use CashuSwift to create proofs
// 2. Lock them with P2PK if supported
// 3. Deduct from wallet balance
⋮----
// For now, create mock proofs
⋮----
// Sign and publish nutzap
⋮----
// Get recipient's preferred relays
let relays = try await getRecipientRelays(request.recipient)
let relaySet = NDKRelaySet(relayURLs: relays, ndk: ndk)
⋮----
// Update balance
⋮----
public func getBalance() async throws -> Int64 {
⋮----
// 1. Load proofs from NIP-60 events
// 2. Check their spent status with mints
// 3. Calculate total balance
⋮----
public func createInvoice(amount _: Int64, description _: String?) async throws -> String {
// This would create a Lightning invoice via mint
⋮----
public func supports(method: NDKPaymentMethod) -> Bool {
⋮----
// MARK: - NIP-60 Event Management
⋮----
/// Save wallet state as NIP-60 events
public func save() async throws {
// Create wallet event (kind 7375)
let walletEvent = NDKEvent(content: "", tags: [])
⋮----
// Add wallet ID tag
⋮----
// Sign and publish
⋮----
/// Load wallet state from NIP-60 events
public func load() async throws {
let filter = try NDKFilter(
⋮----
// Decrypt and parse wallet data
⋮----
// MARK: - Helper Methods
⋮----
let filter = NDKFilter(
⋮----
// Try to get from mint list first
let mintListFilter = NDKFilter(
⋮----
let relays = mintList.relays
⋮----
// Fallback to relay list (NIP-65)
let relayListFilter = NDKFilter(
⋮----
// Fallback to connected relays
⋮----
// MARK: - Supporting Types
⋮----
private struct WalletData: Codable {
let name: String
let mints: [String]
let balance: Int64
⋮----
/// Relay set for publishing events
public struct NDKRelaySet {
let relayURLs: [String]
let ndk: NDK
⋮----
public init(relayURLs: [String], ndk: NDK) {
</file>

<file path="Sources/NDKSwift/Wallet/NDKPaymentRouter.swift">
/// Routes payments to appropriate payment methods based on recipient capabilities
⋮----
private let ndk: NDK
private let walletConfig: NDKWalletConfig
⋮----
/// Pay a user with automatic method selection
⋮----
// Get recipient's payment methods
let paymentMethods = try await getRecipientPaymentMethods(request.recipient)
⋮----
// Try payment methods in order of preference
var lastError: Error?
⋮----
// Try NIP-57 (Lightning) first if available
⋮----
let zapRequest = try await createZapRequest(for: request)
let invoice = try await fetchLightningInvoice(for: request, zapRequest: zapRequest)
⋮----
// Try NIP-61 (Nutzap) if available or as fallback
⋮----
// Create and publish nutzap event
⋮----
// If we get here, all payment methods failed
let error = lastError ?? NDKError.paymentFailed("No payment methods available")
⋮----
/// Get available payment methods for a recipient
⋮----
var methods = Set<NDKPaymentMethod>()
⋮----
// Check for Lightning support (NIP-57)
⋮----
// Check for Cashu mint list (NIP-61)
⋮----
// Parse mint list to verify it has valid mints
let mints = mintListEvent.tags.filter { $0.first == "mint" }.compactMap { $0[safe: 1] }
⋮----
// TODO: Check for NWC support when implemented
⋮----
/// Create a NIP-57 zap request
⋮----
let zapRequest = NDKEvent(content: "", tags: [])
⋮----
["amount", String(request.amount * 1000)], // Convert to millisats
⋮----
/// Fetch Lightning invoice for a zap request
⋮----
// This would typically fetch from the recipient's LNURL endpoint
// For now, this is a placeholder
⋮----
/// Publish a nutzap event
⋮----
let relays = try await getRecipientRelays(request.recipient)
let relaySet = NDKRelaySet(relayURLs: relays, ndk: ndk)
⋮----
/// Get recipient's preferred relays
⋮----
// Try to get relay list from NIP-65
let relayListFilter = NDKFilter(
⋮----
// Fallback to connected relays
⋮----
// MARK: - Errors
⋮----
static func notImplemented(_ message: String) -> NDKError {
</file>

<file path="Sources/NDKSwift/Wallet/NDKWallet.swift">
/// Payment request details
public struct NDKPaymentRequest {
public let recipient: NDKUser
public let amount: Int64 // in satoshis
public let comment: String?
public let tags: [[String]]?
public let unit: String = "sat"
⋮----
public init(recipient: NDKUser, amount: Int64, comment: String? = nil, tags: [[String]]? = nil) {
⋮----
/// Payment confirmation details
public protocol NDKPaymentConfirmation {
⋮----
var recipient: String { get } // pubkey
⋮----
/// Lightning payment confirmation
public struct NDKLightningPaymentConfirmation: NDKPaymentConfirmation {
public let amount: Int64
public let recipient: String
public let timestamp: Date
public let preimage: String
public let paymentRequest: String
⋮----
public init(amount: Int64, recipient: String, timestamp: Date, preimage: String, paymentRequest: String) {
⋮----
/// Cashu payment confirmation
public struct NDKCashuPaymentConfirmation: NDKPaymentConfirmation {
⋮----
public let nutzap: NDKNutzap?
⋮----
public init(amount: Int64, recipient: String, timestamp: Date, nutzap: NDKNutzap? = nil) {
⋮----
/// Base wallet protocol
public protocol NDKWallet {
/// Pay a payment request
⋮----
/// Get wallet balance
⋮----
/// Create a Lightning invoice
⋮----
/// Check if wallet supports a specific payment method
⋮----
/// Payment methods
public enum NDKPaymentMethod: String {
⋮----
/// Wallet configuration for NDK
public struct NDKWalletConfig {
/// Lightning payment callback
public var lnPay: ((NDKPaymentRequest, String) async throws -> NDKLightningPaymentConfirmation?)?
⋮----
/// Cashu payment callback
public var cashuPay: ((NDKPaymentRequest) async throws -> NDKCashuPaymentConfirmation?)?
⋮----
/// Enable automatic fallback to NIP-61 if NIP-57 fails
public var nutzapAsFallback: Bool = false
⋮----
/// Completion callback
public var onPaymentComplete: ((NDKPaymentConfirmation?, Error?) -> Void)?
⋮----
public init(
</file>

<file path="Sources/NDKSwift/NDKSwift.swift">
// Re-export Foundation
</file>

<file path=".gitignore">
.DS_Store
/.build
/Packages
/*.xcodeproj
xcuserdata/
DerivedData/
.swiftpm/config/registries.json
.swiftpm/xcode/package.xcworkspace/contents.xcworkspacedata
.netrc
Examples/.build
Examples/build
*.resolvedndk
.repomix-output.txt
</file>

<file path=".repomixignore">
./Examples
./Documentation
Tests
**/*.md
</file>

<file path=".swiftlint.yml">
# SwiftLint Configuration File
# See full documentation at: https://realm.github.io/SwiftLint/

# Customizable rules
line_length:
  warning: 120 # Warning when lines exceed 120 characters
  error: 150 # Error when lines exceed 150 characters
  ignores_comments: true # Don't count comments toward line length
  ignores_urls: true # Don't count URLs toward line length

# Common naming rules
identifier_name:
  min_length: 
    warning: 2 # Warn when identifiers are shorter than 2 characters
  excluded:
    - id # Allow common short names
    - i
    - j
    - k
    - x
    - y
    - z
    - to
    - URL
    - vm

# Force unwrap rules
force_cast: warning # Warn when force casting is used (as!)
force_try: warning # Warn when force try is used (try!)
force_unwrapping: warning # Warn when force unwrapping is used (variable!)

# Disabled rules
disabled_rules:
  - trailing_whitespace # Allow trailing whitespace
  - todo # Allow TODO comments

# Opt-in rules (these are disabled by default)
opt_in_rules:
  - empty_count # Prefer isEmpty over count == 0
  - empty_string # Prefer isEmpty over string == ""
  - closure_spacing # Consistent spacing in closures
  - fatal_error_message # Require message string in fatalError
  - implicitly_unwrapped_optional # Discourage implicitly unwrapped optionals
  - multiline_parameters # Consistent formatting for multiline parameters
  - vertical_parameter_alignment_on_call # Consistent parameter alignment
  - redundant_nil_coalescing # Warn on redundant nil coalescing (???)
  - unused_import # Warn on unused imports
  - sorted_imports # Keep imports alphabetically sorted
  - unneeded_parentheses_in_closure_argument # Remove unneeded parentheses

# Excluded files/paths
excluded:
  - Pods
  - Carthage
  - .build
  - fastlane
  - vendor
  - DerivedData
  - "generated/**"

# Analyzer rules - helps find deeper issues
analyzer_rules:
  - unused_declaration
  - unused_import

# Warning vs error thresholds for rule violations
warning_threshold: 15 # Turns warnings into errors when there are this many warnings
</file>

<file path="debug_key_generation.swift">
// Simulate the key generation
var bytes = [UInt8](repeating: 0, count: 32)
⋮----
let hexString = bytes.map { String(format: "%02x", $0) }.joined()
⋮----
// Test data conversion
let data = Data(bytes)
⋮----
// Test hex string to data conversion
</file>

<file path="debug_nsec.swift">
// Add a simple test function
let nsecInput = "nsec1pnfm84sp6ed974zj7qsqqcn692hgnf9s48jk8x0psagucv6yy3ys5qqx7c"
⋮----
// Check for invalid characters
let validChars = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
</file>

<file path="Sources/NDKSwift/Blossom/BlossomTypes.swift">
// MARK: - Blossom Types
⋮----
/// Represents a Blossom server
public struct BlossomServer: Codable, Sendable {
public let url: String
public let name: String?
public let description: String?
public let supportedMimeTypes: [String]?
public let maxFileSize: Int64?
⋮----
public init(
⋮----
/// Represents a blob/file in Blossom
public struct BlossomBlob: Codable, Sendable {
public let sha256: String
⋮----
public let size: Int64
public let type: String?
public let uploaded: Date
⋮----
/// Upload descriptor for BUD-02
public struct BlossomUploadDescriptor: Codable {
⋮----
public let uploaded: Int64
⋮----
enum CodingKeys: String, CodingKey {
⋮----
/// List response for BUD-03
public struct BlossomListResponse: Codable {
public let blobs: [BlossomListItem]
⋮----
public struct BlossomListItem: Codable {
⋮----
/// Authorization for Blossom operations
public struct BlossomAuth {
public let event: NDKEvent
⋮----
public init(event: NDKEvent) {
⋮----
/// Create authorization event for upload
public static func createUploadAuth(
⋮----
var tags: [[String]] = [
⋮----
let pubkey = try await signer.pubkey
let event = NDKEvent(
⋮----
kind: 24242, // Blossom auth kind
⋮----
// Generate ID and sign
⋮----
/// Create authorization event for delete
public static func createDeleteAuth(
⋮----
let tags: [[String]] = [
⋮----
/// Create authorization event for list
public static func createListAuth(
⋮----
var event = NDKEvent(
⋮----
/// Get base64-encoded authorization header value
public func authorizationHeaderValue() throws -> String {
let eventJSON = try event.serialize()
let eventData = eventJSON.data(using: .utf8)!
⋮----
/// Blossom error types
public enum BlossomError: LocalizedError {
⋮----
public var errorDescription: String? {
⋮----
/// Blossom server descriptor (from /.well-known/blossom)
public struct BlossomServerDescriptor: Codable {
⋮----
public let icon: String?
public let acceptsMimeTypes: [String]?
public let maxUploadSize: Int64?
public let uploadUrl: String?
public let listUrl: String?
public let deleteUrl: String?
public let mirrorUrl: String?
</file>

<file path="Sources/NDKSwift/Cache/NDKFileCache.swift">
/// File-based cache adapter for NDKSwift
/// Uses JSON files for persistent storage without external dependencies
public final class NDKFileCache: NDKCacheAdapter {
// Protocol requirements
public var locking: Bool = false
public var ready: Bool = true
⋮----
let cacheDirectory: URL
private let eventsDirectory: URL
private let profilesDirectory: URL
private let unpublishedDirectory: URL
private let decryptedDirectory: URL
private let metadataFile: URL
⋮----
// In-memory indexes for fast lookups
private var eventIndex: [String: EventIndexEntry] = [:]
private var profileIndex: [String: Date] = [:]
private var tagIndex: [String: Set<String>] = [:] // tag:value -> Set of event IDs
private var nip05Cache: [String: (pubkey: String, relays: [String], cachedAt: Date)] = [:]
private var relayStatusCache: [String: NDKRelayConnectionState] = [:]
⋮----
// Outbox support
var unpublishedEventIndex: [String: UnpublishedEventRecord] = [:]
var outboxItemIndex: [String: NDKOutboxItem] = [:]
var relayHealthCache: [String: RelayHealthMetrics] = [:]
⋮----
// Thread safety
let queue = DispatchQueue(label: "com.ndkswift.filecache", attributes: .concurrent)
⋮----
private struct EventIndexEntry {
let id: String
let pubkey: String
let kind: Kind
let createdAt: Timestamp
let tags: [[String]]
let replaceableId: String?
⋮----
private struct CacheMetadata: Codable {
var version: Int = 1
var lastUpdated: Date = .init()
var eventCount: Int = 0
var profileCount: Int = 0
⋮----
private struct UnpublishedEventData: Codable {
let event: NDKEvent
var relays: [String]
let lastTryAt: Date
⋮----
public init(path: String = "ndk-file-cache") throws {
// Get documents directory
let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
⋮----
// Create subdirectories
⋮----
// Create directories if they don't exist
⋮----
// Initialize outbox directories
⋮----
// Load indexes
⋮----
private func loadIndexes() throws {
// Load event index
let eventFiles = try FileManager.default.contentsOfDirectory(at: eventsDirectory, includingPropertiesForKeys: nil)
⋮----
let indexEntry = EventIndexEntry(
⋮----
// Build tag index
⋮----
let key = "\(tag[0]):\(tag[1])"
⋮----
// Load profile index - we keep this as is since we only need modification dates
let profileFiles = try FileManager.default.contentsOfDirectory(at: profilesDirectory, includingPropertiesForKeys: nil)
⋮----
let pubkey = file.deletingPathExtension().lastPathComponent
let attributes = try FileManager.default.attributesOfItem(atPath: file.path)
⋮----
// MARK: - NDKCacheAdapter Protocol
⋮----
public func query(subscription: NDKSubscription) async -> [NDKEvent] {
⋮----
var results: [NDKEvent] = []
var seenIds = Set<String>()
⋮----
let matchingEvents = queryWithFilterSync(filter, subscription: subscription)
⋮----
let eventId = event.id ?? UUID().uuidString
⋮----
private func queryWithFilterSync(_ filter: NDKFilter, subscription _: NDKSubscription) -> [NDKEvent] {
var matchingIds = Set<String>()
⋮----
// Start with all events if no specific filters
⋮----
// Filter by IDs
⋮----
let idSet = Set(ids)
⋮----
// Filter by authors
⋮----
let authorEvents = eventIndex.values
⋮----
// Filter by kinds
⋮----
let kindValues = Set(kinds)
let kindEvents = eventIndex.values
⋮----
// Filter by tags
⋮----
var tagMatchingIds = Set<String>()
⋮----
let key = "\(tagName):\(value)"
⋮----
// Apply time filters and load events
var events: [NDKEvent] = []
⋮----
// Check time constraints
⋮----
// Load event from file
let eventFile = eventsDirectory.appendingPathComponent("\(id).json")
⋮----
// Double-check the event matches the filter
⋮----
// Sort by created_at descending
⋮----
// Apply limit
⋮----
public func setEvent(_ event: NDKEvent, filters _: [NDKFilter], relay _: NDKRelay?) async {
⋮----
let referenceId = event.isReplaceable ? event.tagAddress : event.id
⋮----
// Check if we already have a newer version
⋮----
// Remove old replaceable event
⋮----
// Generate ID if needed
⋮----
// Save event to file
let eventFile = self.eventsDirectory.appendingPathComponent("\(eventId).json")
⋮----
// Update index
⋮----
// Update tag index
⋮----
// Handle special event kinds
⋮----
let eventIdsToDelete = event.tags
⋮----
private func removeEventSync(_ eventId: String) {
// Remove from indexes
⋮----
// Remove from tag index
⋮----
// Remove file
let eventFile = eventsDirectory.appendingPathComponent("\(eventId).json")
⋮----
public func fetchProfile(pubkey: String) async -> NDKUserProfile? {
let profileFile = profilesDirectory.appendingPathComponent("\(pubkey).json")
⋮----
public func saveProfile(pubkey: String, profile: NDKUserProfile) async {
⋮----
private func saveProfileSync(pubkey: String, profile: NDKUserProfile) {
⋮----
public func addUnpublishedEvent(_ event: NDKEvent, relayUrls: [String]) async {
⋮----
let unpublishedFile = unpublishedDirectory.appendingPathComponent("\(eventId).json")
⋮----
let record = UnpublishedEventData(
⋮----
public func getUnpublishedEvents() async -> [(event: NDKEvent, relays: [String], lastTryAt: Date)] {
let records = FileManager.default.loadAllCodable(
⋮----
public func discardUnpublishedEvent(_ eventId: String) async {
⋮----
public func clear() async {
⋮----
// Clear all directories
⋮----
// Recreate directories
⋮----
// Clear indexes
⋮----
// MARK: - Additional Methods
⋮----
public func getDecryptedEvent(eventId: String) async -> NDKEvent? {
let decryptedFile = decryptedDirectory.appendingPathComponent("\(eventId).json")
⋮----
public func addDecryptedEvent(_ event: NDKEvent) async {
⋮----
// MARK: - Additional Protocol Methods
⋮----
public func loadNip05(_ nip05: String) async -> (pubkey: PublicKey, relays: [String])? {
⋮----
{ // Cache for 1 hour
⋮----
public func saveNip05(_ nip05: String, pubkey: PublicKey, relays: [String]) async {
⋮----
public func updateRelayStatus(_ url: RelayURL, status: NDKRelayConnectionState) async {
⋮----
public func getRelayStatus(_ url: RelayURL) async -> NDKRelayConnectionState? {
⋮----
public func getUnpublishedEvents(for relayUrl: RelayURL) async -> [NDKEvent] {
⋮----
public func removeUnpublishedEvent(_ eventId: EventID, from relayUrl: RelayURL) async {
⋮----
// Read the file to check if we should remove it entirely or just update the relay list
⋮----
// Remove the file entirely if no relays left
⋮----
// Update the file with remaining relays
⋮----
// MARK: - NDKUserProfile Extensions
⋮----
static func fromMetadataEvent(_ event: NDKEvent) -> NDKUserProfile? {
</file>

<file path="Sources/NDKSwift/Cache/NDKFileCacheOutbox.swift">
/// Extension to NDKFileCache for outbox support
⋮----
// MARK: - Unpublished Event Management
⋮----
public func storeUnpublishedEvent(
⋮----
let record = UnpublishedEventRecord(
⋮----
let filePath = self.outboxDirectory
⋮----
// Update index
⋮----
public func getAllUnpublishedEvents() async -> [UnpublishedEventRecord] {
⋮----
let records = Array(self.unpublishedEventIndex.values)
⋮----
public func updateUnpublishedEventStatus(
⋮----
// Create mutable copy with updated status
var updatedStatuses = record.relayStatuses
⋮----
let updatedRecord = UnpublishedEventRecord(
⋮----
// Save to file
⋮----
public func markEventAsPublished(eventId: String) async {
⋮----
// Remove from unpublished index
⋮----
// Delete file
⋮----
public func getEventsForRetry(olderThan interval: TimeInterval) async -> [UnpublishedEventRecord] {
⋮----
let records = self.unpublishedEventIndex.values.filter { record in
⋮----
public func cleanupPublishedEvents(olderThan age: TimeInterval) async {
⋮----
let cutoffDate = Date().addingTimeInterval(-age)
⋮----
let toRemove = self.unpublishedEventIndex.filter { _, record in
⋮----
// MARK: - Outbox Relay Information
⋮----
public func storeOutboxItem(_ item: NDKOutboxItem) async {
⋮----
let filePath = self.outboxRelayDirectory
⋮----
public func getOutboxItem(for pubkey: String) async -> NDKOutboxItem? {
⋮----
public func updateRelayHealth(url: String, health: RelayHealthMetrics) async {
⋮----
// Persist to file
let fileName = url.replacingOccurrences(of: "/", with: "_")
⋮----
let filePath = self.relayHealthDirectory
⋮----
public func getRelayHealth(url: String) async -> RelayHealthMetrics? {
⋮----
// MARK: - Private Helpers
⋮----
private func calculateOverallStatus(
⋮----
let successCount = statuses.values.filter { $0 == .succeeded }.count
let failureCount = statuses.values.filter {
⋮----
let pendingCount = statuses.values.filter {
⋮----
let minRequired = config?.minSuccessfulRelays ?? 1
⋮----
// MARK: - Additional Properties for Outbox Support
⋮----
// Additional directories for outbox
var outboxDirectory: URL {
⋮----
var outboxRelayDirectory: URL {
⋮----
var relayHealthDirectory: URL {
⋮----
// MARK: - Initialize Outbox Directories
⋮----
func initializeOutboxDirectories() throws {
⋮----
// Load existing outbox data
⋮----
private func loadOutboxData() {
// Load unpublished events
let unpublishedRecords = FileManager.default.loadAllCodable(
⋮----
// Load outbox items
let outboxItems = FileManager.default.loadAllCodableWithFilenames(
⋮----
// Load relay health
let healthMetrics = FileManager.default.loadAllCodable(
</file>

<file path="Sources/NDKSwift/Core/SignatureVerification/NDKSignatureVerificationSampler.swift">
/// Main signature verification sampler that handles sampling logic and evil relay detection
public actor NDKSignatureVerificationSampler {
/// Configuration for signature verification
private let config: NDKSignatureVerificationConfig
⋮----
/// Cache for verified signatures
private let cache: NDKSignatureVerificationCache
⋮----
/// Blacklisted relay URLs
private var blacklistedRelays: Set<String> = []
⋮----
/// Delegate for signature verification events
public weak var delegate: NDKSignatureVerificationDelegate?
⋮----
/// Statistics tracking
private var totalVerifications: Int = 0
private var failedVerifications: Int = 0
⋮----
public init(config: NDKSignatureVerificationConfig) {
⋮----
/// Verify an event's signature with sampling
/// - Parameters:
///   - event: The event to verify
///   - relay: The relay that provided the event
///   - stats: The relay's signature statistics
/// - Returns: The verification result
public func verifyEvent(_ event: NDKEvent, from relay: NDKRelay, stats: inout NDKRelaySignatureStats) async -> NDKSignatureVerificationResult {
⋮----
// Check if relay is blacklisted
⋮----
// Check cache first
⋮----
// Determine if we should verify based on sampling
let shouldVerify = shouldVerifyEvent(relay: relay, stats: stats)
⋮----
// Skip verification due to sampling
⋮----
// Perform actual signature verification
let isValid = verifySignature(event: event)
⋮----
// Cache the verified signature
⋮----
// Invalid signature detected - this relay is evil!
⋮----
/// Check if a relay is blacklisted
public func isBlacklisted(relay: NDKRelay) -> Bool {
⋮----
/// Get blacklisted relay URLs
public func getBlacklistedRelays() -> Set<String> {
⋮----
/// Clear the signature cache
public func clearCache() async {
⋮----
/// Get verification statistics
public func getStats() -> (totalVerifications: Int, failedVerifications: Int, blacklistedRelays: Int) {
⋮----
/// Set the signature verification delegate
public func setDelegate(_ delegate: NDKSignatureVerificationDelegate?) {
⋮----
// MARK: - Private Methods
⋮----
/// Determine if we should verify an event based on sampling
private func shouldVerifyEvent(relay _: NDKRelay, stats: NDKRelaySignatureStats) -> Bool {
let ratio = stats.currentValidationRatio
⋮----
// Always verify if ratio is 1.0
⋮----
// Otherwise, randomly decide based on ratio
⋮----
/// Update the validation ratio for a relay
private func updateValidationRatio(relay: NDKRelay, stats: inout NDKRelaySignatureStats) {
let newRatio: Double
⋮----
// Use custom function if provided
⋮----
// Use default exponential decay function
⋮----
/// Default validation ratio calculation with exponential decay
private func calculateDefaultValidationRatio(validatedCount: Int, initialRatio: Double, lowestRatio: Double) -> Double {
// Start with full validation for the first 10 events
⋮----
// Exponential decay: ratio = initial * e^(-0.01 * validatedCount)
// This gradually decreases the ratio as more events are successfully validated
let decayFactor = 0.01
let newRatio = initialRatio * exp(-decayFactor * Double(validatedCount))
⋮----
// Never go below the minimum ratio
⋮----
/// Verify the actual signature
private func verifySignature(event: NDKEvent) -> Bool {
⋮----
// Generate the expected event ID
let calculatedId = try event.generateID()
⋮----
// Verify the ID matches
⋮----
// Verify the signature
let messageData = Data(hexString: eventId) ?? Data()
⋮----
/// Handle an invalid signature detection
private func handleInvalidSignature(event: NDKEvent, relay: NDKRelay) async {
// A single invalid signature means the relay is evil
⋮----
// Notify delegate on main thread
let delegateCopy = delegate
⋮----
// Blacklist the relay if configured
⋮----
// Notify delegate about blacklisting
⋮----
// Disconnect from the relay
</file>

<file path="Sources/NDKSwift/Models/NDKUser.swift">
/// Represents a Nostr user
⋮----
/// User's public key
public let pubkey: PublicKey
⋮----
/// Reference to NDK instance
public weak var ndk: NDK?
⋮----
/// User's profile metadata
public private(set) var profile: NDKUserProfile?
⋮----
/// Relay list (NIP-65)
public private(set) var relayList: [NDKRelayInfo] = []
⋮----
/// User's NIP-05 identifier
public var nip05: String? {
⋮----
/// NIP-46 relay URLs (for remote signing)
public var nip46Urls: [String]?
⋮----
/// Display name (from profile)
public var displayName: String? {
⋮----
/// Profile name
public var name: String? {
⋮----
// MARK: - Initialization
⋮----
/// Create user from npub
⋮----
let pubkey = try Bech32.pubkey(from: npub)
⋮----
/// Create user from NIP-05 identifier
public static func fromNip05(_ nip05: String, ndk: NDK) async throws -> NDKUser {
// Parse NIP-05 identifier (user@domain)
let parts = nip05.split(separator: "@")
⋮----
let name = String(parts[0])
let domain = String(parts[1])
⋮----
// Build the well-known URL
let urlString = "https://\(domain)/.well-known/nostr.json?name=\(name)"
⋮----
// Fetch the data
⋮----
// Parse JSON response
⋮----
let user = NDKUser(pubkey: pubkey)
⋮----
// Check for NIP-46 relays
⋮----
// MARK: - Profile Management
⋮----
/// Fetch user's profile
/// - Parameter forceRefresh: If true, bypasses cache and fetches fresh data from relays
/// - Returns: The user's profile, or nil if not found
⋮----
// Check cache first unless force refresh is requested
⋮----
// Create filter for kind 0 events
let filter = NDKFilter(
⋮----
// Fetch the profile event
⋮----
// Parse the profile from the event content
⋮----
// Update our local profile
⋮----
// Save to cache
⋮----
/// Update profile with new metadata
⋮----
/// Fetch user's relay list (NIP-65)
⋮----
public func fetchRelayList() async throws -> [NDKRelayInfo] {
⋮----
// Create filter for kind 10002 events
⋮----
// TODO: Implement subscription and fetch
// For now, return empty array
⋮----
// MARK: - Following/Followers
⋮----
/// Get users this user follows
public func follows() async throws -> Set<NDKUser> {
⋮----
// Create filter for kind 3 events
⋮----
// Parse 'p' tags from contact list
⋮----
/// Check if this user follows another user
public func follows(_ user: NDKUser) async throws -> Bool {
let followList = try await follows()
⋮----
// MARK: - Utilities
⋮----
/// Get npub representation
public var npub: String {
⋮----
// Fallback to placeholder if encoding fails
⋮----
/// Get shortened public key for display
public var shortPubkey: String {
⋮----
// MARK: - Equatable & Hashable
⋮----
public func hash(into hasher: inout Hasher) {
⋮----
// MARK: - Payments
⋮----
/// Pay this user using the configured wallet
/// - Parameters:
///   - amount: Amount in satoshis
///   - comment: Optional comment for the payment
///   - tags: Optional additional tags
/// - Returns: Payment confirmation
public func pay(amount: Int64, comment: String? = nil, tags: [[String]]? = nil) async throws -> NDKPaymentConfirmation {
⋮----
let request = NDKPaymentRequest(
⋮----
/// Get available payment methods for this user
/// - Returns: Set of payment methods this user supports
⋮----
var methods = Set<NDKPaymentMethod>()
⋮----
// Check for Lightning support (NIP-57)
⋮----
// Check for Cashu mint list (NIP-61)
⋮----
// Check if user has valid mints
let mintTags = mintListEvent.tags.filter { $0.first == "mint" }
⋮----
// TODO: Check for NWC support when implemented
⋮----
/// User profile metadata (kind 0)
⋮----
public var displayName: String?
public var about: String?
public var picture: String?
public var banner: String?
public var nip05: String?
public var lud16: String?
public var lud06: String?
public var website: String?
⋮----
// Additional fields
private var additionalFields: [String: String] = [:]
⋮----
// MARK: - Codable
⋮----
private struct DynamicCodingKey: CodingKey {
var stringValue: String
var intValue: Int?
⋮----
init?(stringValue: String) {
⋮----
init?(intValue _: Int) {
⋮----
let container = try decoder.container(keyedBy: DynamicCodingKey.self)
⋮----
// Store any additional fields
let knownKeys = ["name", "display_name", "about", "picture", "banner", "nip05", "lud16", "lud06", "website"]
⋮----
public func encode(to encoder: Encoder) throws {
var container = encoder.container(keyedBy: DynamicCodingKey.self)
⋮----
// Encode additional fields
⋮----
/// Get additional field value
public func additionalField(_ key: String) -> String? {
⋮----
/// Set additional field value
public mutating func setAdditionalField(_ key: String, value: String?) {
</file>

<file path="Sources/NDKSwift/Outbox/NDKPublishingStrategy.swift">
/// Manages publishing events using the outbox model with retry logic and status tracking
public actor NDKPublishingStrategy {
private let ndk: NDK
private let selector: NDKRelaySelector
private let ranker: NDKRelayRanker
⋮----
/// Active outbox items being published
private var outboxItems: [String: OutboxItem] = [:]
⋮----
/// Queue of items waiting to be published
private var publishQueue: [OutboxItem] = []
⋮----
/// Active publishing tasks
private var activeTasks: [String: Task<Void, Never>] = [:]
⋮----
public init(ndk: NDK, selector: NDKRelaySelector, ranker: NDKRelayRanker) {
⋮----
/// Publish an event using the outbox model
⋮----
public func publish(
⋮----
// Select target relays
let selection = await selector.selectRelaysForPublishing(
⋮----
// Create outbox item
let item = OutboxItem(
⋮----
// Store in outbox
⋮----
// Start publishing
let task = Task {
⋮----
// Wait for initial results if not background
⋮----
// Return current status
⋮----
/// Get the current status of a publishing operation
public func getPublishResult(for eventId: String) -> PublishResult {
⋮----
/// Cancel publishing for an event
public func cancelPublish(eventId: String) {
⋮----
/// Get all pending outbox items
public func getPendingItems() -> [OutboxItem] {
⋮----
/// Clean up completed items older than specified age
public func cleanupCompleted(olderThan age: TimeInterval = 3600) {
let cutoffDate = Date().addingTimeInterval(-age)
⋮----
// Keep if not completed or recent
⋮----
// MARK: - Private Methods
⋮----
private func publishOutboxItem(_ item: OutboxItem) async {
⋮----
// Create tasks for each relay
⋮----
// Update overall status
⋮----
private func publishToRelay(item: OutboxItem, relayURL: String) async {
var attempts = 0
var backoffInterval: TimeInterval = item.config.initialBackoffInterval
⋮----
// Check if cancelled
⋮----
// Get or establish connection
⋮----
// Attempt to publish
let startTime = Date()
let result = await attemptPublishToRelay(
⋮----
let responseTime = Date().timeIntervalSince(startTime)
⋮----
// Handle POW requirement
⋮----
// Retry with new event (POW added)
attempts = 0 // Reset attempts for POW retry
⋮----
// Exponential backoff
⋮----
// Attempt NIP-42 auth
⋮----
// Retry after auth
⋮----
private func attemptPublishToRelay(
⋮----
// Send event
let response = try await relay.publish(event)
⋮----
// Parse response
⋮----
// Extract difficulty
let difficulty = extractPowDifficulty(from: message) ?? 20
⋮----
// Network or other errors
⋮----
private func handlePowRequirement(item: OutboxItem, difficulty: Int) async -> Bool {
// Update required difficulty
⋮----
// Check if we should generate POW
⋮----
// Generate POW
// TODO: Implement POW generation when available
// For now, we can't generate POW, so return false
⋮----
private func handleAuthChallenge(relay _: NDKRelay) async -> Bool {
// This would implement NIP-42 auth
// For now, returning false as auth implementation is relay-specific
⋮----
private func getOrConnectRelay(url: String) async -> NDKRelay? {
// First check if already connected
⋮----
// Try to connect
⋮----
private func updateOverallStatus(for item: OutboxItem) {
let successCount = item.relayStatuses.values.filter { $0 == .succeeded }.count
let failureCount = item.relayStatuses.values.filter {
⋮----
let pendingCount = item.relayStatuses.values.filter {
⋮----
private func extractPowDifficulty(from message: String) -> Int? {
// Extract difficulty from message like "pow: difficulty 20 required"
let pattern = #"pow:.*?(\d+)"#
⋮----
let container = try decoder.container(keyedBy: CodingKeys.self)
let type = try container.decode(String.self, forKey: .type)
⋮----
let reason = try container.decode(PublishFailureReason.self, forKey: .reason)
⋮----
let attempt = try container.decode(Int.self, forKey: .attempt)
⋮----
/// Reason for publish failure
public enum PublishFailureReason: Equatable, Codable {
⋮----
enum CodingKeys: String, CodingKey {
⋮----
public func encode(to encoder: Encoder) throws {
var container = encoder.container(keyedBy: CodingKeys.self)
⋮----
let message = try container.decode(String.self, forKey: .message)
⋮----
/// Result of a publish attempt
private enum PublishAttemptResult {
⋮----
/// Result of a publish operation
public struct PublishResult {
public let eventId: String
public let overallStatus: PublishStatus
public let relayStatuses: [String: RelayPublishStatus]
public let successCount: Int
public let failureCount: Int
public let powDifficulty: Int?
⋮----
public var isComplete: Bool {
</file>

<file path="Sources/NDKSwift/Outbox/NDKRelaySelector.swift">
/// Intelligently selects relays for publishing and fetching based on the outbox model
public actor NDKRelaySelector {
private let ndk: NDK
private let tracker: NDKOutboxTracker
private let ranker: NDKRelayRanker
⋮----
public init(ndk: NDK, tracker: NDKOutboxTracker, ranker: NDKRelayRanker) {
⋮----
/// Select relays for publishing an event
public func selectRelaysForPublishing(
⋮----
var targetRelays = Set<String>()
var missingRelayPubkeys = Set<String>()
⋮----
// 1. Add user's primary write relays
⋮----
// Fallback to read relays if no write relays
⋮----
// 2. Add contextual relays from event tags
let contextualRelays = await extractContextualRelays(from: event, for: .publishing)
⋮----
// 3. Special handling for NIP-65 relay lists
⋮----
// For relay lists, also publish to read relays
⋮----
// 4. Apply fallback if needed
⋮----
let fallbackRelays = await selectFallbackRelays(
⋮----
// 5. Rank and limit relays
let rankedRelays = await ranker.rankRelays(
⋮----
let selectedRelays = Array(rankedRelays.prefix(config.maxRelayCount))
⋮----
/// Select relays for fetching events
public func selectRelaysForFetching(
⋮----
var sourceRelays = Set<String>()
⋮----
// 1. Add user's primary read relays
let userPubkey = try? await ndk.signer?.pubkey
⋮----
// 2. Add author-specific relays
⋮----
let authorRelays = await selectRelaysForAuthors(
⋮----
// 3. Add contextual relays from filter tags
let contextualRelays = await extractContextualRelaysFromFilter(filter)
⋮----
let authors = filter.authors ?? []
let taggedPubkeys = extractPubkeysFromFilter(filter)
let allRelevantPubkeys = authors + taggedPubkeys + (userPubkey.map { [$0] } ?? [])
⋮----
/// Choose relay combination for multiple pubkeys (optimized for minimal connections)
public func chooseRelayCombinationForPubkeys(
⋮----
var relayToPubkeys = RelayToPubkeysMap()
let connectedRelays = ndk.relayPool.connectedRelays()
⋮----
// Track how many relays each pubkey has been assigned to
var pubkeyRelayCount: [String: Int] = [:]
⋮----
// Get relay info for all pubkeys
let pubkeyRelayInfo = await getAllRelaysForPubkeys(pubkeys, type: type)
⋮----
// First pass: Use connected relays
⋮----
let pubkeysInRelay = pubkeyRelayInfo.pubkeysToRelays
⋮----
// Second pass: Add relays for pubkeys that need more coverage
let sortedRelays = await ranker.getTopRelaysForAuthors(pubkeys)
⋮----
let currentCount = pubkeyRelayCount[pubkey, default: 0]
⋮----
// Add relays until we reach the target
⋮----
var pubkeysInRelay = relayToPubkeys[relayURL, default: []]
⋮----
// Third pass: Add fallback relays for pubkeys with no relays
let fallbackRelays = await selectFallbackRelays(currentCount: 0, targetCount: 2)
⋮----
// MARK: - Private Methods
⋮----
private func extractContextualRelays(
⋮----
var relays = Set<String>()
var missingPubkeys = Set<String>()
⋮----
// Extract from e tags (reply/quote context)
⋮----
// Extract from p tags (mentioned users)
⋮----
// Publish to where mentioned users write and read
⋮----
// Fetch from where mentioned users read
⋮----
private func extractContextualRelaysFromFilter(
⋮----
// Extract from #p tags
⋮----
private func selectRelaysForAuthors(
⋮----
private func selectFallbackRelays(
⋮----
let neededCount = targetCount - currentCount
⋮----
// Get default relays from pool
let poolRelays = ndk.relayPool.relays
⋮----
private func getAllRelaysForPubkeys(
⋮----
var pubkeysToRelays: [String: Set<String>] = [:]
var authorsMissingRelays = Set<String>()
⋮----
let relays: Set<String>
⋮----
private func extractPubkeysFromFilter(_ filter: NDKFilter) -> [String] {
var pubkeys: [String] = []
⋮----
private func determineSelectionMethod(_ relays: Set<String>) -> SelectionMethod {
// Simple heuristic - could be expanded
⋮----
// MARK: - Configuration Types
⋮----
/// Configuration for publishing events
public struct PublishingConfig {
public let minRelayCount: Int
public let maxRelayCount: Int
public let includeUserReadRelays: Bool
public let rankingPreferences: RelayPreferences
⋮----
public init(
⋮----
public static let `default` = PublishingConfig()
⋮----
/// Configuration for fetching events
public struct FetchingConfig {
⋮----
public let preferWriteRelaysIfNoRead: Bool
⋮----
public static let `default` = FetchingConfig()
⋮----
/// Configuration for relay combination selection
public struct CombinationConfig {
public let relaysPerAuthor: Int
⋮----
public init(relaysPerAuthor: Int = 2) {
⋮----
public static let `default` = CombinationConfig()
⋮----
// MARK: - Result Types
⋮----
/// Result of relay selection
public struct RelaySelectionResult {
public let relays: Set<String>
public let missingRelayInfoPubkeys: Set<String>
public let selectionMethod: SelectionMethod
⋮----
/// Map of relay URLs to pubkeys
⋮----
/// Purpose of relay selection
private enum RelayPurpose {
⋮----
/// Method used for relay selection
public enum SelectionMethod {
</file>

<file path="Sources/NDKSwift/Core/Types.swift">
/// 32-byte lowercase hex-encoded public key
⋮----
/// 32-byte lowercase hex-encoded private key
⋮----
/// 32-byte lowercase hex-encoded event ID
⋮----
/// 64-byte lowercase hex-encoded signature
⋮----
/// Unix timestamp in seconds
⋮----
/// Relay URL
⋮----
/// Nostr event kind
⋮----
/// Common Nostr event kinds
public enum EventKind {
public static let metadata = 0
public static let textNote = 1
public static let recommendRelay = 2
public static let contacts = 3
public static let encryptedDirectMessage = 4
public static let deletion = 5
public static let repost = 6
public static let reaction = 7
public static let badgeAward = 8
public static let image = 20
public static let channelCreation = 40
public static let channelMetadata = 41
public static let channelMessage = 42
public static let channelHideMessage = 43
public static let channelMuteUser = 44
public static let fileMetadata = 1063
public static let zapRequest = 9734
public static let zap = 9735
public static let muteList = 10000
public static let pinList = 10001
public static let relayList = 10002
public static let walletInfo = 13194
public static let clientAuthentication = 22242
public static let walletRequest = 23194
public static let walletResponse = 23195
public static let nostrConnect = 24133
public static let httpAuth = 27235
public static let categorizedPeople = 30000
public static let categorizedBookmarks = 30001
public static let profileBadges = 30008
public static let badgeDefinition = 30009
public static let longFormContent = 30023
public static let applicationSpecificData = 30078
// Cashu/NIP-60 kinds
public static let cashuReserve = 7373
public static let cashuQuote = 7374
public static let cashuToken = 7375
public static let cashuWalletTx = 7376
public static let cashuWallet = 17375
public static let cashuWalletBackup = 375
// NIP-61
public static let nutzap = 9321
public static let cashuMintList = 10019
⋮----
/// Tag structure
⋮----
/// Imeta tag representation
public struct NDKImetaTag {
public var url: String?
public var blurhash: String?
public var dim: String?
public var alt: String?
public var m: String?
public var x: String?
public var size: String?
public var fallback: [String]?
public var additionalFields: [String: String] = [:]
⋮----
public init(
⋮----
/// OK message from relay
public struct OKMessage: Equatable {
public let accepted: Bool
public let message: String?
public let receivedAt: Date
⋮----
/// NDK Error types
public enum NDKError: Error, LocalizedError, Equatable {
⋮----
public var errorDescription: String? {
</file>

<file path="Sources/NDKSwift/Models/NDKFilter.swift">
/// Filter for subscribing to events
public struct NDKFilter: Codable, Equatable {
/// Event IDs to filter
public var ids: [EventID]?
⋮----
/// Pubkeys of event authors
public var authors: [PublicKey]?
⋮----
/// Event kinds
public var kinds: [Kind]?
⋮----
/// Referenced event IDs (in 'e' tags)
public var events: [EventID]?
⋮----
/// Referenced pubkeys (in 'p' tags)
public var pubkeys: [PublicKey]?
⋮----
/// Events created after this timestamp
public var since: Timestamp?
⋮----
/// Events created before this timestamp
public var until: Timestamp?
⋮----
/// Maximum number of events to return
public var limit: Int?
⋮----
/// Generic tag filters
private var tagFilters: [String: [String]] = [:]
⋮----
// MARK: - Initialization
⋮----
public init(
⋮----
// Convert tags to tagFilters format
⋮----
// MARK: - Tag Filters
⋮----
/// Add a generic tag filter
public mutating func addTagFilter(_ tagName: String, values: [String]) {
⋮----
/// Get tag filter values
public func tagFilter(_ tagName: String) -> [String]? {
⋮----
/// Get all tag filters as a dictionary
public var tags: [String: Set<String>]? {
⋮----
var result: [String: Set<String>] = [:]
⋮----
// Remove the # prefix
let tagName = String(key.dropFirst())
⋮----
// MARK: - Codable
⋮----
private struct DynamicCodingKey: CodingKey {
var stringValue: String
var intValue: Int?
⋮----
init?(stringValue: String) {
⋮----
init?(intValue _: Int) {
⋮----
public init(from decoder: Decoder) throws {
let container = try decoder.container(keyedBy: DynamicCodingKey.self)
⋮----
// Decode standard fields
⋮----
// Handle special tag filters
⋮----
// Decode generic tag filters
⋮----
public func encode(to encoder: Encoder) throws {
var container = encoder.container(keyedBy: DynamicCodingKey.self)
⋮----
// Encode standard fields
⋮----
// Encode special tag filters
⋮----
// Encode generic tag filters
⋮----
// MARK: - Matching
⋮----
/// Check if an event matches this filter
public func matches(event: NDKEvent) -> Bool {
// Check IDs
⋮----
// Check authors
⋮----
// Check kinds
⋮----
// Check timestamp
⋮----
// Check referenced events
⋮----
let eventRefs = event.tags(withName: "e").compactMap { $0.count > 1 ? $0[1] : nil }
⋮----
// Check referenced pubkeys
⋮----
let pubkeyRefs = event.tags(withName: "p").compactMap { $0.count > 1 ? $0[1] : nil }
⋮----
// Check generic tag filters
⋮----
let tagName = String(tagKey.dropFirst()) // Remove '#'
let eventTagValues = event.tags(withName: tagName).compactMap { $0.count > 1 ? $0[1] : nil }
⋮----
// MARK: - Utilities
⋮----
/// Check if this filter is more specific than another
public func isMoreSpecific(than other: NDKFilter) -> Bool {
var specificityScore = 0
var otherScore = 0
⋮----
// Compare each field
⋮----
/// Merge with another filter
public func merged(with other: NDKFilter) -> NDKFilter? {
var merged = NDKFilter()
⋮----
// For arrays, we need to find common elements
⋮----
let common = Set(selfIds).intersection(Set(otherIds))
⋮----
let common = Set(selfAuthors).intersection(Set(otherAuthors))
⋮----
let common = Set(selfKinds).intersection(Set(otherKinds))
⋮----
// For timestamps, use the most restrictive range
let mergedSince = max(since ?? 0, other.since ?? 0)
let mergedUntil = min(until ?? .max, other.until ?? .max)
⋮----
// For limit, use the smaller one
⋮----
/// Merge with another filter using union semantics (for profile batching)
public func mergedUnion(with other: NDKFilter) -> NDKFilter? {
// Only allow union merging for compatible filters
⋮----
// Union arrays
⋮----
// For union merging, kinds must match exactly
⋮----
// For timestamps, use the most inclusive range
⋮----
// For limit, sum them up (capped at some reasonable max)
⋮----
// Don't merge if tag filters differ
⋮----
/// Check if this filter can be union-merged with another
private func canMergeUnion(with other: NDKFilter) -> Bool {
// Only allow union merging for metadata (profile) queries
⋮----
let selfKindSet = Set(selfKinds)
let otherKindSet = Set(otherKinds)
⋮----
// Both must be requesting only metadata events
⋮----
// Don't merge if either has tag filters, events, or pubkeys
⋮----
/// Returns a dictionary representation of the filter
public var dictionary: [String: Any] {
var dict: [String: Any] = [:]
⋮----
// Add generic tag filters
</file>

<file path="Sources/NDKSwift/Relay/NDKRelayConnection.swift">
/// Delegate for relay connection events
public protocol NDKRelayConnectionDelegate: AnyObject {
⋮----
/// WebSocket connection to a Nostr relay
public final class NDKRelayConnection {
private let url: URL
⋮----
private var webSocketTask: URLSessionWebSocketTask?
private let urlSession: URLSession
⋮----
private let queue = DispatchQueue(label: "com.ndkswift.relay", qos: .utility)
⋮----
public weak var delegate: NDKRelayConnectionDelegate?
⋮----
/// Current connection state
public private(set) var isConnected = false
⋮----
/// Connection statistics
public private(set) var messagesSent = 0
public private(set) var messagesReceived = 0
public private(set) var connectedAt: Date?
⋮----
/// Retry policy for reconnection
private let retryPolicy = RetryPolicy(configuration: .relayConnection)
⋮----
public init(url: URL) {
⋮----
let config = URLSessionConfiguration.default
⋮----
deinit {
⋮----
// MARK: - Connection Management
⋮----
/// Connect to the relay
public func connect() {
⋮----
private func _connect() {
⋮----
// Create WebSocket request
var request = URLRequest(url: url)
⋮----
// Create WebSocket task
⋮----
// Start receiving messages
⋮----
// Monitor connection state
⋮----
// Mock connection for Linux
⋮----
/// Disconnect from relay
public func disconnect() {
⋮----
private func _disconnect() {
⋮----
// MARK: - Message Handling
⋮----
/// Send a message to the relay
public func send(_ message: NostrMessage) async throws {
let json = try message.serialize()
⋮----
/// Send raw JSON to relay
public func send(_ json: String) async throws {
⋮----
let message = URLSessionWebSocketTask.Message.string(json)
⋮----
// Mock sending for Linux
⋮----
private func receiveMessage() {
⋮----
// Continue receiving
⋮----
private func handleReceivedMessage(_ json: String) {
⋮----
let message = try NostrMessage.parse(from: json)
⋮----
// Log parsing error but continue
⋮----
// MARK: - Connection Monitoring
⋮----
private func monitorConnection() {
⋮----
// Use a simple ping to check connection status
⋮----
private func checkConnectionState() {
⋮----
retryPolicy.reset() // Reset on successful connection
⋮----
// Handle suspended state
⋮----
private func handleConnectionError(_ error: Error) {
⋮----
// Schedule reconnection
⋮----
private func scheduleReconnection() {
</file>

<file path="Sources/NDKSwift/Relay/NDKRelaySubscriptionManager.swift">
/// Manages subscriptions at the relay level with filter merging and reconnection support
public actor NDKRelaySubscriptionManager {
// MARK: - Types
⋮----
/// Represents a relay-level subscription that can contain multiple NDKSubscriptions
public struct RelaySubscription {
let id: String
var subscriptions: [NDKSubscription] = []
var mergedFilters: [NDKFilter]
let closeOnEose: Bool
var status: RelaySubscriptionStatus = .initial
var lastExecuted: Date?
⋮----
/// Add a subscription to this relay subscription
mutating func addSubscription(_ subscription: NDKSubscription, filters _: [NDKFilter]) {
⋮----
// Re-merge filters when adding new subscription
⋮----
/// Remove a subscription from this relay subscription
mutating func removeSubscription(_ subscriptionId: String) {
⋮----
// Re-merge filters after removal
⋮----
/// Check if this relay subscription should be closed
var shouldClose: Bool {
⋮----
/// Status of a relay subscription
public enum RelaySubscriptionStatus {
⋮----
case waiting // Waiting for relay to be ready
⋮----
/// Filter fingerprint for grouping
public struct FilterFingerprint: Hashable {
let kinds: String
let authorsPresent: Bool
let tagKeys: String
let hasLimit: Bool
let hasTimeConstraints: Bool
⋮----
init(filters: [NDKFilter], closeOnEose: Bool) {
// Sort kinds for consistent fingerprinting
let allKinds = filters.compactMap { $0.kinds }.flatMap { $0 }.sorted()
⋮----
// Extract tag keys from filters
let tagKeys = filters.compactMap { filter -> [String]? in
⋮----
// MARK: - Properties
⋮----
private weak var relay: NDKRelay?
⋮----
/// Map of fingerprint to relay subscriptions for grouping
private var subscriptionsByFingerprint: [FilterFingerprint: [RelaySubscription]] = [:]
⋮----
/// Map of subscription ID to relay subscription for quick lookup
private var subscriptionIdToRelaySubscription: [String: String] = [:]
⋮----
/// All relay subscriptions by ID
private var relaySubscriptions: [String: RelaySubscription] = [:]
⋮----
/// Whether to enable subscription grouping
private let enableGrouping: Bool = true
⋮----
/// Maximum filters per subscription request
private let maxFiltersPerRequest: Int = 10
⋮----
// MARK: - Initialization
⋮----
public init(relay: NDKRelay) {
⋮----
// Observe relay connection state for replay
⋮----
// MARK: - Public Interface
⋮----
/// Add a subscription to be managed
public func addSubscription(_ subscription: NDKSubscription, filters: [NDKFilter]) -> String {
⋮----
// No grouping, create individual relay subscription
⋮----
// Check if subscription can be grouped
let fingerprint = FilterFingerprint(filters: filters, closeOnEose: subscription.options.closeOnEose)
⋮----
// Find existing relay subscription that can accept this subscription
⋮----
// Can add to this subscription
⋮----
// Create new relay subscription
⋮----
/// Remove a subscription
public func removeSubscription(_ subscriptionId: String) {
⋮----
// Close and remove relay subscription
⋮----
// Update with modified filters
⋮----
// If running, send updated filters to relay
⋮----
/// Execute all pending subscriptions
public func executePendingSubscriptions() async {
let pending = relaySubscriptions.values.filter { $0.status == .pending || $0.status == .waiting }
⋮----
/// Get all active subscription IDs
public func getActiveSubscriptionIds() -> [String] {
⋮----
/// Handle EOSE for a relay subscription
public func handleEOSE(relaySubscriptionId: String) {
⋮----
// Notify all subscriptions in this group
⋮----
// Track EOSE received
⋮----
// Close if all subscriptions want closeOnEose
⋮----
// Remove subscriptions from tracking
⋮----
/// Handle event for routing to appropriate subscriptions
public func handleEvent(_ event: NDKEvent, relaySubscriptionId: String?) {
⋮----
// If we have a specific relay subscription ID, route only to those subscriptions
⋮----
let matches = subscription.filters.contains(where: { $0.matches(event: event) })
⋮----
// Track event received
⋮----
isUnique: true // NDKSubscriptionManager handles deduplication
⋮----
// Route to all matching subscriptions
⋮----
// MARK: - Private Implementation
⋮----
private func createIndividualSubscription(_ subscription: NDKSubscription, filters: [NDKFilter]) -> String {
// Use subscription ID as the relay sub ID for wire protocol, but make it unique per relay
let relaySubId = subscription.id
let relaySub = RelaySubscription(
⋮----
// Execute immediately
⋮----
private func createGroupedSubscription(_ subscription: NDKSubscription, filters: [NDKFilter], fingerprint: FilterFingerprint) -> String {
let relaySubId = subscription.id // Use the subscription's own ID for now
var relaySub = RelaySubscription(
⋮----
// Add to fingerprint map
⋮----
// Execute immediately to avoid race conditions
⋮----
private func executeRelaySubscription(_ relaySubId: String) async {
⋮----
// Check relay connection
⋮----
// Don't re-execute if already running
⋮----
// Send subscription to relay
⋮----
let reqMessage = NostrMessage.req(subscriptionId: relaySubId, filters: relaySub.mergedFilters)
⋮----
// Register subscription with relay
⋮----
// Track subscription sent to relay with actual filters
⋮----
// Handle error
⋮----
private func updateSubscriptionFilters(_ relaySubId: String) async {
⋮----
// Close old subscription
⋮----
let closeMessage = NostrMessage.close(subscriptionId: relaySubId)
⋮----
// Ignore close errors
⋮----
// Send new subscription with updated filters
⋮----
private func closeRelaySubscription(_ relaySubId: String) {
⋮----
// Remove from fingerprint map
let fingerprint = FilterFingerprint(filters: relaySub.mergedFilters, closeOnEose: relaySub.closeOnEose)
⋮----
// Send close message to relay
⋮----
// MARK: - Relay Connection Observation
⋮----
private func observeRelayConnection() async {
⋮----
// Monitor connection state changes
⋮----
private func handleConnectionStateChange(_ state: NDKRelayConnectionState) async {
⋮----
// Replay waiting subscriptions
⋮----
// Mark running subscriptions as waiting
⋮----
private func replayWaitingSubscriptions() async {
let waiting = relaySubscriptions.values.filter { $0.status == .waiting }
⋮----
private func markSubscriptionsAsWaiting() async {
⋮----
// MARK: - Filter Merging
⋮----
/// Merge filters from multiple subscriptions
static func mergeAllFilters(from subscriptions: [(NDKSubscription, [NDKFilter])]) -> [NDKFilter] {
var mergedFilters: [NDKFilter] = []
var filtersWithLimits: [NDKFilter] = []
var filtersWithoutLimits: [NDKFilter] = []
⋮----
// Separate filters with and without limits
⋮----
// Filters with limits are not merged
⋮----
// Merge filters without limits
⋮----
let merged = mergeFiltersWithoutLimits(filtersWithoutLimits)
⋮----
/// Merge filters that don't have limits
private static func mergeFiltersWithoutLimits(_ filters: [NDKFilter]) -> NDKFilter {
var merged = NDKFilter()
⋮----
// Merge kinds
let allKinds = filters.compactMap { $0.kinds }.flatMap { $0 }
⋮----
// Merge authors
let allAuthors = filters.compactMap { $0.authors }.flatMap { $0 }
⋮----
// Merge IDs
let allIds = filters.compactMap { $0.ids }.flatMap { $0 }
⋮----
// Merge tags
var mergedTags: [String: [String]] = [:]
⋮----
// Convert merged tags to proper format and add to filter
⋮----
// Handle time constraints (use most restrictive)
let sinceValues = filters.compactMap { $0.since }
⋮----
merged.since = sinceValues.max() // Most recent since
⋮----
let untilValues = filters.compactMap { $0.until }
⋮----
merged.until = untilValues.min() // Earliest until
</file>

<file path="Sources/NDKSwift/Relay/NostrMessage.swift">
/// Nostr message types
public enum NostrMessageType: String {
⋮----
/// Nostr message protocol
public enum NostrMessage {
⋮----
/// Parse a message from relay
public static func parse(from json: String) throws -> NostrMessage {
⋮----
let array = try JSONSerialization.jsonObject(with: data) as? [Any]
⋮----
let subscriptionId = array.count > 2 ? array[1] as? String : nil
let eventIndex = subscriptionId != nil ? 2 : 1
⋮----
let event = try JSONCoding.decodeFromDictionary(NDKEvent.self, from: eventDict)
⋮----
var filters: [NDKFilter] = []
⋮----
let filter = try JSONCoding.decodeFromDictionary(NDKFilter.self, from: filterDict)
⋮----
let message = array.count > 3 ? array[3] as? String : nil
⋮----
/// Serialize message to send to relay
public func serialize() throws -> String {
var array: [Any] = []
⋮----
let eventDict = try JSONCoding.encodeToDictionary(event)
⋮----
let filterDict = try JSONCoding.encodeToDictionary(filter)
⋮----
let data = try JSONSerialization.data(withJSONObject: array, options: [.withoutEscapingSlashes])
⋮----
/// Get the subscription ID if applicable
public var subscriptionId: String? {
</file>

<file path="Sources/NDKSwift/Subscription/NDKSubscriptionManager.swift">
/// Advanced subscription manager that handles grouping, merging, and coordination
public actor NDKSubscriptionManager {
// MARK: - Types
⋮----
/// Subscription execution state
public enum SubscriptionState {
⋮----
/// Cache usage strategy for subscriptions
public enum CacheUsage {
case onlyCache // Cache only, no relays
case cacheFirst // Cache then relays if needed
case parallel // Cache + relays simultaneously
case onlyRelay // Skip cache entirely
⋮----
/// Subscription execution plan
struct ExecutionPlan {
let subscriptions: [NDKSubscription]
let mergedFilters: [NDKFilter]
let relaySet: Set<NDKRelay>
let cacheUsage: CacheUsage
let closeOnEose: Bool
let delay: TimeInterval
⋮----
/// Filter fingerprint for grouping compatibility
struct FilterFingerprint: Hashable {
let kinds: Set<Int>?
let authorsCount: Int
let tagTypes: Set<String>
let hasTimeConstraints: Bool
let hasLimit: Bool
⋮----
init(filter: NDKFilter, closeOnEose: Bool) {
⋮----
// Note: tagNames property doesn't exist in current NDKFilter, use empty set
⋮----
// MARK: - Properties
⋮----
private weak var ndk: NDK?
private var activeSubscriptions: [String: NDKSubscription] = [:]
private var subscriptionStates: [String: SubscriptionState] = [:]
private var pendingGroups: [FilterFingerprint: PendingGroup] = [:]
private var eventDeduplication: [EventID: Timestamp] = [:]
private var eoseTracking: [String: EOSETracker] = [:]
⋮----
/// Configuration
private let maxFiltersPerRequest = 10
private let groupingDelay: TimeInterval = 0.1
private let deduplicationWindow: TimeInterval = 300 // 5 minutes
private let eoseTimeoutRatio: Double = 0.5 // 50% of relays for timeout
⋮----
/// Statistics
private var stats = SubscriptionStats()
⋮----
// MARK: - Pending Group Management
⋮----
private struct PendingGroup {
var subscriptions: [NDKSubscription] = []
var timer: Task<Void, Never>?
var createdAt: Date = .init()
⋮----
mutating func addSubscription(_ subscription: NDKSubscription) {
⋮----
mutating func cancel() {
⋮----
// MARK: - EOSE Tracking
⋮----
private struct EOSETracker {
let targetRelays: Set<NDKRelay>
var eosedRelays: Set<NDKRelay> = []
var lastEventReceived: Date = .init()
let createdAt: Date = .init()
⋮----
var eosePercentage: Double {
⋮----
var shouldTimeout: Bool {
let timeSinceLastEvent = Date().timeIntervalSince(lastEventReceived)
let timeSinceCreation = Date().timeIntervalSince(createdAt)
⋮----
// Don't timeout too early or if we recently received events
⋮----
mutating func recordEose(from relay: NDKRelay) {
⋮----
mutating func recordEvent() {
⋮----
// MARK: - Statistics
⋮----
public struct SubscriptionStats {
public var totalSubscriptions: Int = 0
public var activeSubscriptions: Int = 0
public var groupedSubscriptions: Int = 0
public var requestsSaved: Int = 0
public var eventsDeduped: Int = 0
public var averageGroupSize: Double = 0
⋮----
mutating func recordGrouping(originalCount: Int, finalCount: Int) {
⋮----
// MARK: - Initialization
⋮----
public init(ndk: NDK) {
⋮----
// Start cleanup timer for deduplication
⋮----
// MARK: - Public Interface
⋮----
/// Add a subscription to be managed
public func addSubscription(_ subscription: NDKSubscription) {
⋮----
// Track subscription creation
⋮----
// Determine execution strategy
⋮----
/// Remove a subscription
public func removeSubscription(_ subscriptionId: String) {
⋮----
// Track subscription closure
⋮----
/// Process an event from a relay
public func processEvent(_ event: NDKEvent, from relay: NDKRelay) {
⋮----
// Check deduplication
let now = Timestamp(Date().timeIntervalSince1970)
let isUnique = eventDeduplication[eventId] == nil
⋮----
// Already seen this event
⋮----
// Find matching subscriptions and dispatch
⋮----
// Track event received
⋮----
// Update EOSE tracking
⋮----
/// Process EOSE from a relay
public func processEOSE(subscriptionId: String, from relay: NDKRelay) {
⋮----
// Track EOSE received
⋮----
// Check if we should emit EOSE for this subscription
⋮----
/// Get current statistics
public func getStats() -> SubscriptionStats {
⋮----
// MARK: - Grouping Logic
⋮----
private func shouldGroupSubscription(_ subscription: NDKSubscription) -> Bool {
// Don't group if:
// - Subscription has specific relays
// - Has time constraints that make grouping unsafe
// - Is cache-only
// - Has a very small limit that shouldn't be shared
⋮----
// Check for time constraints that make grouping risky
⋮----
private func addToGrouping(_ subscription: NDKSubscription) {
⋮----
// Create fingerprint for grouping
let fingerprint = createFingerprint(for: subscription)
⋮----
// Add to existing group
⋮----
// Create new group
var group = PendingGroup()
⋮----
// Set timer to execute group
⋮----
private func createFingerprint(for subscription: NDKSubscription) -> FilterFingerprint {
// For now, create fingerprint from first filter
// In a more sophisticated implementation, we'd analyze all filters
⋮----
private func executeGroup(fingerprint: FilterFingerprint) {
⋮----
// Create execution plan
let plan = createExecutionPlan(for: group.subscriptions)
⋮----
// Execute the plan
⋮----
// Update statistics
⋮----
private func createExecutionPlan(for subscriptions: [NDKSubscription]) -> ExecutionPlan {
// Merge compatible filters
let mergedFilters = mergeFilters(from: subscriptions)
⋮----
// Determine relay set (use intersection of all subscription relay preferences)
var relaySet: Set<NDKRelay> = []
⋮----
// Determine cache usage (most restrictive wins)
let cacheUsage = subscriptions.map { $0.options.cacheStrategy }.min { a, b in
⋮----
// Determine close behavior (all must agree)
let closeOnEose = subscriptions.allSatisfy { $0.options.closeOnEose }
⋮----
private func mergeFilters(from subscriptions: [NDKSubscription]) -> [NDKFilter] {
var result: [NDKFilter] = []
var processed: Set<String> = []
⋮----
let filterId = "\(filter.kinds ?? [])_\(filter.authors?.count ?? 0)" // Simple approach
⋮----
// Try to merge with existing filters
var merged = false
⋮----
// Respect maximum filters per request
⋮----
private func executeImmediately(_ subscription: NDKSubscription) {
let plan = ExecutionPlan(
⋮----
private func executeSubscriptionGroup(_ plan: ExecutionPlan) {
⋮----
// Mark subscriptions as executing
⋮----
// Setup EOSE tracking
⋮----
// Handle cache first if needed
⋮----
// Execute relay queries if needed
⋮----
// Mark as active
⋮----
private func executeCacheQuery(_ plan: ExecutionPlan) async {
⋮----
let cachedEvents = await cache.query(subscription: subscription)
⋮----
// For cache-only, emit EOSE
⋮----
private func executeRelayQueries(_ plan: ExecutionPlan) async {
⋮----
// Send subscription to each relay using their subscription managers
⋮----
// Register with relay's subscription manager
⋮----
// MARK: - Utilities
⋮----
private func cacheStrategyPriority(_ strategy: NDKCacheStrategy) -> Int {
⋮----
private func cacheUsageFromStrategy(_ strategy: NDKCacheStrategy) -> CacheUsage {
⋮----
// MARK: - Cleanup
⋮----
private func startPeriodicCleanup() async {
⋮----
try? await Task.sleep(nanoseconds: 60_000_000_000) // 1 minute
⋮----
private func performCleanup() {
⋮----
let cutoff = now - Int64(deduplicationWindow)
⋮----
// Clean old event deduplication entries
⋮----
// Clean closed subscriptions
let closedSubscriptions = activeSubscriptions.filter { _, subscription in
</file>

<file path="Sources/NDKSwift/Utils/Bech32.swift">
/// Bech32 encoding/decoding utilities for Nostr entities
public enum Bech32 {
/// Bech32 character set
private static let charset = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
⋮----
/// Generator coefficients for checksum
private static let generator: [UInt32] = [0x3B6A_57B2, 0x2650_8E6D, 0x1EA1_19FA, 0x3D42_33DD, 0x2A14_62B3]
⋮----
/// Errors that can occur during Bech32 operations
public enum Bech32Error: Error, LocalizedError {
⋮----
public var errorDescription: String? {
⋮----
/// Encode data to bech32
public static func encode(hrp: String, data: [UInt8]) throws -> String {
let values = try convertBits(data: data, fromBits: 8, toBits: 5, pad: true)
let checksum = createChecksum(hrp: hrp, values: values)
let combined = values + checksum
⋮----
let encoded = combined.map { charset[charset.index(charset.startIndex, offsetBy: Int($0))] }
⋮----
/// Decode bech32 string
public static func decode(_ bech32: String) throws -> (hrp: String, data: [UInt8]) {
⋮----
let hrp = String(bech32[..<separatorIndex]).lowercased()
let dataString = String(bech32[bech32.index(after: separatorIndex)...]).lowercased()
⋮----
var values: [UInt8] = []
⋮----
let checksumLength = 6
let dataValues = Array(values.dropLast(checksumLength))
⋮----
let data = try convertBits(data: dataValues, fromBits: 5, toBits: 8, pad: false)
⋮----
/// Convert bits
private static func convertBits(data: [UInt8], fromBits: Int, toBits: Int, pad: Bool) throws -> [UInt8] {
var acc = 0
var bits = 0
var result: [UInt8] = []
let maxv = (1 << toBits) - 1
let maxAcc = (1 << (fromBits + toBits - 1)) - 1
⋮----
/// Create checksum
private static func createChecksum(hrp: String, values: [UInt8]) -> [UInt8] {
let polymod = polymodStep(pre: 1, values: hrpExpand(hrp) + values + [0, 0, 0, 0, 0, 0]) ^ 1
⋮----
/// Verify checksum
private static func verifyChecksum(hrp: String, values: [UInt8]) -> Bool {
⋮----
/// HRP expansion
private static func hrpExpand(_ hrp: String) -> [UInt8] {
⋮----
/// Polymod step
private static func polymodStep(pre: UInt32, values: [UInt8]) -> UInt32 {
var chk = pre
⋮----
let b = chk >> 25
⋮----
/// Nostr-specific Bech32 encoding/decoding
⋮----
/// Check if a string is a valid bech32 format
static func isBech32(_ string: String) -> Bool {
// Must contain separator '1'
⋮----
// HRP must not be empty
let hrp = String(string[..<separatorIndex])
⋮----
// Data part must not be empty
let dataString = String(string[string.index(after: separatorIndex)...])
⋮----
// Check if all characters after separator are in bech32 charset
⋮----
/// Get the HRP (human readable part) from a bech32 string without full validation
static func getHRP(_ string: String) -> String? {
⋮----
let hrp = String(string[..<separatorIndex]).lowercased()
⋮----
/// Encode a public key to npub format
static func npub(from pubkey: PublicKey) throws -> String {
⋮----
/// Decode npub to public key
static func pubkey(from npub: String) throws -> PublicKey {
⋮----
/// Encode a private key to nsec format
static func nsec(from privateKey: PrivateKey) throws -> String {
⋮----
/// Decode nsec to private key
static func privateKey(from nsec: String) throws -> PrivateKey {
⋮----
/// Encode an event ID to note format
static func note(from eventId: EventID) throws -> String {
⋮----
/// Decode note to event ID
static func eventId(from note: String) throws -> EventID {
⋮----
/// Encode event with optional metadata to nevent format
static func nevent(
⋮----
var tlvData: [UInt8] = []
⋮----
// Type 0: Event ID (32 bytes)
⋮----
// Type 1: Relay hints (optional)
⋮----
let relayData = Array(relay.utf8)
⋮----
// Type 2: Author (optional)
⋮----
// Type 3: Kind (optional)
⋮----
let kindBytes = withUnsafeBytes(of: UInt32(kind).bigEndian) { Array($0) }
⋮----
/// Encode addressable event to naddr format
static func naddr(
⋮----
// Type 0: Identifier
let identifierData = Array(identifier.utf8)
⋮----
// Type 2: Author (required)
⋮----
// Type 3: Kind (required)
</file>

<file path="Package.resolved">
{
  "pins" : [
    {
      "identity" : "cryptoswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/krzyzanowskim/CryptoSwift.git",
      "state" : {
        "revision" : "729e01bc9b9dab466ac85f21fb9ee2bc1c61b258",
        "version" : "1.8.4"
      }
    },
    {
      "identity" : "secp256k1.swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/GigaBitcoin/secp256k1.swift.git",
      "state" : {
        "revision" : "8c62aba8a3011c9bcea232e5ee007fb0b34a15e2",
        "version" : "0.21.1"
      }
    }
  ],
  "version" : 2
}
</file>

<file path="Sources/NDKSwift/Models/NDKRelay.swift">
/// Relay information for NIP-65
public struct NDKRelayInfo: Codable, Equatable {
public let url: RelayURL
public let read: Bool
public let write: Bool
⋮----
public init(url: RelayURL, read: Bool = true, write: Bool = true) {
⋮----
/// Relay connection state
public enum NDKRelayConnectionState: Equatable {
⋮----
case failed(String) // Store error message instead of Error for Equatable
⋮----
/// Relay statistics
public struct NDKRelayStats {
public var connectedAt: Date?
public var lastMessageAt: Date?
public var messagesSent: Int = 0
public var messagesReceived: Int = 0
public var bytesReceived: Int = 0
public var bytesSent: Int = 0
public var latency: TimeInterval?
public var connectionAttempts: Int = 0
public var successfulConnections: Int = 0
⋮----
/// Signature verification statistics
public var signatureStats: NDKRelaySignatureStats = .init()
⋮----
/// Represents a Nostr relay
public final class NDKRelay: Hashable, Equatable {
/// Relay URL
⋮----
/// Current connection state
public private(set) var connectionState: NDKRelayConnectionState = .disconnected
⋮----
public private(set) var stats = NDKRelayStats()
⋮----
/// Relay information (NIP-11)
public private(set) var info: NDKRelayInformation?
⋮----
/// Active subscriptions on this relay
private var subscriptions: [String: NDKSubscription] = [:]
⋮----
/// Connection state observers
private var stateObservers: [(NDKRelayConnectionState) -> Void] = []
⋮----
/// Reference to NDK instance
public weak var ndk: NDK?
⋮----
/// WebSocket connection
private var connection: NDKRelayConnection?
⋮----
/// Reconnection timer
private var reconnectTimer: Timer?
⋮----
/// Current reconnection delay
private var reconnectDelay: TimeInterval = 1.0
⋮----
/// Maximum reconnection delay
private let maxReconnectDelay: TimeInterval = 300.0 // 5 minutes
⋮----
/// Subscription manager for this relay
public lazy var subscriptionManager = NDKRelaySubscriptionManager(relay: self)
⋮----
/// Thread-safe access to statistics
private let statsLock = NSLock()
⋮----
/// Thread-safe access to subscriptions
private let subscriptionsLock = NSLock()
⋮----
// MARK: - Initialization
⋮----
public init(url: RelayURL) {
⋮----
// MARK: - Connection Management
⋮----
/// Connect to the relay
public func connect() async throws {
⋮----
/// Disconnect from the relay
public func disconnect() async {
⋮----
// Cancel reconnection timer
⋮----
/// Handle connection failure with exponential backoff
private func handleConnectionFailure(_ error: Error) {
⋮----
// Schedule reconnection with exponential backoff
let delay = min(reconnectDelay, maxReconnectDelay)
⋮----
// MARK: - Relay Information
⋮----
/// Fetch relay information (NIP-11)
private func fetchRelayInformation() async {
// TODO: Implement NIP-11 relay information fetching
// GET request to relay URL with Accept: application/nostr+json
⋮----
// MARK: - Subscription Management
⋮----
/// Add a subscription to this relay
public func addSubscription(_ subscription: NDKSubscription) {
⋮----
/// Remove a subscription from this relay
public func removeSubscription(_ subscription: NDKSubscription) {
⋮----
/// Remove a subscription by ID from this relay (safer for async contexts)
public func removeSubscription(byId subscriptionId: String) {
⋮----
/// Get all active subscriptions
public var activeSubscriptions: [NDKSubscription] {
⋮----
// MARK: - Message Handling
⋮----
/// Send a message to the relay
public func send(_ message: String) async throws {
⋮----
/// Handle received message
private func handleMessage(_ message: String) {
⋮----
// Parse and route message
⋮----
let nostrMessage = try NostrMessage.parse(from: message)
⋮----
// Log parsing error but don't crash
⋮----
/// Route parsed message to appropriate handlers
private func routeMessage(_ message: NostrMessage) {
⋮----
// These are client->relay messages, shouldn't receive them
⋮----
/// Handle EVENT message
private func handleEventMessage(_ event: NDKEvent, subscriptionId: String?) {
// Set relay reference on event
⋮----
// Route to subscription manager via NDK
⋮----
// Also notify local subscriptions for backward compatibility
⋮----
let subscription = subscriptions[subscriptionId]
⋮----
/// Handle EOSE message
private func handleEOSEMessage(subscriptionId: String) {
⋮----
// Also notify local subscription for backward compatibility
⋮----
/// Handle OK message (publish result)
private func handleOKMessage(eventId: EventID, accepted: Bool, message: String?) {
⋮----
let status = accepted ? "✅ Accepted" : "❌ Rejected"
let msg = message.map { ": \($0)" } ?? ""
⋮----
// Notify NDK about OK message
⋮----
/// Handle NOTICE message
private func handleNoticeMessage(_ message: String) {
⋮----
// TODO: Emit notice event for listeners
⋮----
/// Handle AUTH message
private func handleAuthMessage(challenge: String) {
⋮----
// TODO: Handle NIP-42 authentication
⋮----
/// Handle COUNT message
private func handleCountMessage(subscriptionId: String, count: Int) {
⋮----
// TODO: Handle NIP-45 count results
⋮----
// MARK: - State Management
⋮----
/// Update connection state and notify observers
private func updateConnectionState(_ newState: NDKRelayConnectionState) {
⋮----
// Notify observers
⋮----
/// Observe connection state changes
public func observeConnectionState(_ observer: @escaping (NDKRelayConnectionState) -> Void) {
⋮----
// Immediately call with current state
⋮----
// MARK: - Utilities
⋮----
/// Check if relay is currently connected
public var isConnected: Bool {
⋮----
/// Get normalized relay URL
public var normalizedURL: String {
// Use the URLNormalizer for consistent normalization
⋮----
// MARK: - NDKRelayConnectionDelegate
⋮----
public func relayConnectionDidConnect(_: NDKRelayConnection) {
⋮----
reconnectDelay = 1.0 // Reset delay on successful connection
⋮----
// Fetch relay information and replay subscriptions
⋮----
// Replay any waiting subscriptions
⋮----
public func relayConnectionDidDisconnect(_: NDKRelayConnection, error: Error?) {
⋮----
public func relayConnection(_: NDKRelayConnection, didReceiveMessage message: NostrMessage) {
⋮----
private func handleNostrMessage(_ message: NostrMessage) {
⋮----
// Route through subscription manager first
⋮----
// Also handle legacy subscriptions for backward compatibility
⋮----
let subscription = subscriptions[subId]
⋮----
// Route through subscription manager
⋮----
// Also handle legacy subscriptions
⋮----
// Handle event publishing confirmation
⋮----
// Handle authentication challenge
⋮----
// Handle other message types as needed
⋮----
private func handleAuthChallenge(_ challenge: String) {
// TODO: Implement NIP-42 authentication
⋮----
// MARK: - Signature Statistics
⋮----
/// Update signature verification statistics in a thread-safe manner
func updateSignatureStats(_ update: (inout NDKRelaySignatureStats) -> Void) {
⋮----
/// Get a copy of the current signature statistics
func getSignatureStats() -> NDKRelaySignatureStats {
⋮----
// MARK: - Hashable & Equatable
⋮----
func hash(into hasher: inout Hasher) {
⋮----
/// Relay information from NIP-11
public struct NDKRelayInformation: Codable {
public let name: String?
public let description: String?
public let pubkey: PublicKey?
public let contact: String?
public let supportedNips: [Int]?
public let software: String?
public let version: String?
public let limitation: RelayLimitation?
public let retention: [RelayRetention]?
public let relayCountries: [String]?
public let languageTags: [String]?
public let tags: [String]?
public let postingPolicy: String?
public let paymentsUrl: String?
public let fees: RelayFees?
⋮----
private enum CodingKeys: String, CodingKey {
⋮----
/// Relay limitations
public struct RelayLimitation: Codable {
public let maxMessageLength: Int?
public let maxSubscriptions: Int?
public let maxFilters: Int?
public let maxLimit: Int?
public let maxSubidLength: Int?
public let maxEventTags: Int?
public let maxContentLength: Int?
public let minPowDifficulty: Int?
public let authRequired: Bool?
public let paymentRequired: Bool?
public let restrictedWrites: Bool?
⋮----
/// Relay retention policy
public struct RelayRetention: Codable {
public let kinds: [Int]?
public let time: Int?
public let count: Int?
⋮----
/// Relay fee structure
public struct RelayFees: Codable {
public let admission: [RelayFee]?
public let publication: [RelayFee]?
⋮----
/// Individual relay fee
public struct RelayFee: Codable {
public let amount: Int
public let unit: String
public let period: Int?
</file>

<file path="Sources/NDKSwift/Signers/NDKBunkerSigner.swift">
/// Helper struct for parsing bunker URLs
struct BunkerURLParser {
let urlString: String
⋮----
func parse() -> (bunkerPubkey: String?, userPubkey: String?, relays: [String], secret: String?) {
⋮----
var bunkerPubkey: String?
var userPubkey: String?
var relays: [String] = []
var secret: String?
⋮----
// Extract bunker pubkey from hostname or path
⋮----
// Handle bunker://pubkey format
let path = url.path
⋮----
// Parse query parameters
⋮----
/// NIP-46 remote signer implementation supporting both bunker:// and nostrconnect:// flows
public actor NDKBunkerSigner: NDKSigner, @unchecked Sendable {
private let ndk: NDK
private var userPubkey: String?
private var bunkerPubkey: String?
private var relayUrls: [String]
private var secret: String?
private let localSigner: NDKPrivateKeySigner
private var subscription: NDKSubscription?
private var rpcClient: NDKNostrRPC?
⋮----
/// For nostrconnect:// flow
private var nostrConnectSecret: String?
public private(set) var nostrConnectUri: String?
⋮----
/// Authentication URL emitted when user needs to authorize
public let authUrlPublisher = PassthroughSubject<String, Never>()
⋮----
/// Connection state
private var isConnected = false
private var connectionContinuation: CheckedContinuation<NDKUser, Error>?
⋮----
private enum ConnectionType {
⋮----
private let connectionType: ConnectionType
⋮----
/// Options for nostrconnect:// URI generation
public struct NostrConnectOptions {
public let name: String?
public let url: String?
public let image: String?
public let perms: String?
⋮----
public init(name: String? = nil, url: String? = nil, image: String? = nil, perms: String? = nil) {
⋮----
// MARK: - Static Factory Methods
⋮----
/// Create a bunker signer with bunker:// connection string
public static func bunker(ndk: NDK, connectionToken: String, localSigner: NDKPrivateKeySigner? = nil) -> NDKBunkerSigner {
let signer = localSigner ?? (try! NDKPrivateKeySigner.generate())
⋮----
/// Create a bunker signer with NIP-05
public static func nip05(ndk: NDK, nip05: String, localSigner: NDKPrivateKeySigner? = nil) -> NDKBunkerSigner {
⋮----
/// Create a nostrconnect signer
public static func nostrConnect(ndk: NDK, relay: String, localSigner: NDKPrivateKeySigner? = nil, options: NostrConnectOptions? = nil) -> NDKBunkerSigner {
⋮----
// MARK: - Initialization
⋮----
private init(ndk: NDK, connectionType: ConnectionType, localSigner: NDKPrivateKeySigner) {
⋮----
break // Will be handled in connect()
⋮----
private func parseBunkerUrl(_ urlString: String) {
let parser = BunkerURLParser(urlString: urlString)
⋮----
private func initNostrConnect(relay: String, options: NostrConnectOptions?) {
⋮----
// Generate nostrconnect:// URI - Note: pubkey will be set later
⋮----
let pubkey = try? await localSigner.pubkey
⋮----
private func generateNostrConnectUri(pubkey: String, relay: String, options: NostrConnectOptions?) {
var uri = "nostrconnect://\(pubkey)"
var params: [String] = []
⋮----
private func generateNostrConnectSecret() -> String {
⋮----
// MARK: - Connection
⋮----
/// Connect and authenticate with the bunker
public func connect() async throws -> NDKUser {
⋮----
// Handle NIP-05 flow
⋮----
let user = try await NDKUser.fromNip05(nip05, ndk: ndk)
⋮----
// Ensure relays are added and connected
⋮----
let relay = ndk.addRelay(relayUrl)
⋮----
// Connect to the relay if not already connected
⋮----
// Wait a bit for connections to stabilize
try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
⋮----
// Initialize RPC client
⋮----
let rpcClient = NDKNostrRPC(ndk: ndk, localSigner: localSigner, relayUrls: relayUrls)
⋮----
// Start listening for responses
⋮----
// Handle different connection flows
⋮----
private func startListening() async throws {
⋮----
let localPubkey = try await localSigner.pubkey
⋮----
let filter = NDKFilter(
kinds: [24133], // NostrConnect kind
⋮----
// Create subscription with specific relays if available
⋮----
var options = NDKSubscriptionOptions()
let relayObjects = relayUrls.compactMap { url in
⋮----
// Listen for events
⋮----
private func connectNostrConnect() async throws -> NDKUser {
⋮----
// Wait for connect response with our secret
// The response handler will resume the continuation
⋮----
private func connectBunker() async throws -> NDKUser {
⋮----
let params = [userPubkey ?? "", secret ?? ""].filter { !$0.isEmpty }
let maskedParams = params.enumerated().map { index, param in
⋮----
private func handleIncomingEvent(_ event: NDKEvent) async {
⋮----
let parsed = try await rpcClient.parseEvent(event)
⋮----
// Handle incoming requests (not implemented in this basic version)
⋮----
private func handleResponse(_ response: NDKRPCResponse) async {
// Handle auth_url
⋮----
// Handle nostrconnect flow
⋮----
let user = NDKUser(pubkey: response.event.pubkey)
⋮----
// Handle connect response
⋮----
private func handleConnectResponse(_ response: NDKRPCResponse) async {
⋮----
let pubkey = try await getPublicKey()
⋮----
let user = NDKUser(pubkey: pubkey)
⋮----
let error = NDKError.signerError(response.error ?? "Connection failed")
⋮----
// MARK: - NDKSigner Protocol
⋮----
public var pubkey: String {
⋮----
let user = try await connect()
⋮----
private func performSign(_ event: NDKEvent) async throws -> Signature {
⋮----
let eventJson = try event.serialize()
⋮----
let response = try await rpcClient?.sendRequest(
⋮----
public func sign(_ event: NDKEvent) async throws -> Signature {
⋮----
public func sign(event: inout NDKEvent) async throws {
⋮----
public func getPublicKey() async throws -> String {
⋮----
private func performCrypto(method: String, params: [String], errorMessage: String) async throws -> String {
⋮----
public func encrypt(recipient: NDKUser, value: String, scheme: NDKEncryptionScheme) async throws -> String {
let method = scheme == .nip04 ? "nip04_encrypt" : "nip44_encrypt"
⋮----
public func decrypt(sender: NDKUser, value: String, scheme: NDKEncryptionScheme) async throws -> String {
let method = scheme == .nip04 ? "nip04_decrypt" : "nip44_decrypt"
⋮----
public func user() async throws -> NDKUser {
⋮----
// MARK: - Cleanup
⋮----
public func disconnect() {
subscription = nil // This will automatically clean up
⋮----
deinit {
// Clean up synchronously
</file>

<file path="Sources/NDKSwift/Models/NDKEvent.swift">
/// Represents a Nostr event
public final class NDKEvent: Codable, Equatable, Hashable {
/// Unique event ID (32-byte hash)
public var id: EventID?
⋮----
/// Public key of the event creator
public var pubkey: PublicKey
⋮----
/// Unix timestamp when the event was created
public var createdAt: Timestamp
⋮----
/// Event kind
public var kind: Kind
⋮----
/// Event tags
public var tags: [Tag]
⋮----
/// Event content
public var content: String
⋮----
/// Event signature
public var sig: Signature?
⋮----
/// Reference to NDK instance
public weak var ndk: NDK?
⋮----
/// Relay that this event was received from
public private(set) var relay: NDKRelay?
⋮----
/// Internal method to set relay (called by relay when processing events)
func setRelay(_ relay: NDKRelay) {
⋮----
/// Tracks which relays this event has been seen on
public private(set) var seenOnRelays: Set<String> = []
⋮----
/// Tracks publish status for each relay
public private(set) var relayPublishStatuses: [String: RelayPublishStatus] = [:]
⋮----
/// Tracks OK messages from relays
public private(set) var relayOKMessages: [String: OKMessage] = [:]
⋮----
/// Custom properties for extension
private var customProperties: [String: Any] = [:]
⋮----
// MARK: - Relay Tracking Methods
⋮----
/// Mark event as seen on a relay
public func markSeenOn(relay: String) {
⋮----
/// Update publish status for a relay
public func updatePublishStatus(relay: String, status: RelayPublishStatus) {
⋮----
/// Store OK message from a relay
public func addOKMessage(relay: String, accepted: Bool, message: String?) {
⋮----
/// Get all relays where this event was successfully published
public var successfullyPublishedRelays: [String] {
⋮----
/// Get all relays where publishing failed
public var failedPublishRelays: [String] {
⋮----
/// Check if event was published to at least one relay
public var wasPublished: Bool {
⋮----
// MARK: - Initialization
⋮----
public init(
⋮----
/// Convenience initializer for creating events that will be signed later
public convenience init(content: String = "", tags: [Tag] = []) {
⋮----
// MARK: - Codable
⋮----
private enum CodingKeys: String, CodingKey {
⋮----
public init(from decoder: Decoder) throws {
let container = try decoder.container(keyedBy: CodingKeys.self)
⋮----
// MARK: - Event ID Generation
⋮----
/// Generate event ID based on NIP-01
public func generateID() throws -> EventID {
let serialized = try serializeForID()
let data = serialized.data(using: .utf8)!
let hash = data.sha256()
let id = hash.toHexString()
⋮----
/// Serialize event for ID generation according to NIP-01
private func serializeForID() throws -> String {
// [0, pubkey, created_at, kind, tags, content]
let encoder = JSONEncoder()
⋮----
let array: [Any] = [
⋮----
let data = try JSONSerialization.data(withJSONObject: array, options: [.withoutEscapingSlashes])
⋮----
// MARK: - Validation
⋮----
/// Validate event structure
public func validate() throws {
// Validate public key
⋮----
// Validate ID if present
⋮----
// Verify ID matches content
let calculatedID = try generateID()
⋮----
// Validate signature if present
⋮----
// MARK: - Tag Helpers
⋮----
/// Get all tags of a specific type
public func tags(withName name: String) -> [Tag] {
⋮----
/// Get the first tag of a specific type
public func tag(withName name: String) -> Tag? {
⋮----
/// Add a tag
public func addTag(_ tag: Tag) {
⋮----
/// Add a 'p' tag for mentioning a user
public func tag(user: NDKUser, marker: String? = nil) {
var tag = ["p", user.pubkey]
⋮----
/// Add an 'e' tag for referencing an event
public func tag(event: NDKEvent, marker: String? = nil, relay: String? = nil) {
⋮----
var tag = ["e", eventID]
⋮----
tag.append("") // Empty relay URL
⋮----
/// Generate content tags from the event's content
/// This scans for hashtags, nostr entities (npub, note, etc.) and adds appropriate tags
public func generateContentTags() {
let contentTag = ContentTagger.generateContentTags(from: content, existingTags: tags)
⋮----
/// Convenience method to set content and generate tags automatically
public func setContent(_ newContent: String, generateTags: Bool = true) {
⋮----
/// Get all referenced event IDs
public var referencedEventIds: [EventID] {
⋮----
/// Get all referenced pubkeys
public var referencedPubkeys: [PublicKey] {
⋮----
// MARK: - Equatable & Hashable
⋮----
// Events are equal if they have the same ID
⋮----
public func hash(into hasher: inout Hasher) {
⋮----
// MARK: - Signing
⋮----
/// Sign this event using the NDK instance's signer
public func sign() async throws {
⋮----
// Set pubkey from signer if not already set
⋮----
// Generate content tags before signing
⋮----
// Generate ID if not already set
⋮----
// Sign the event
⋮----
// MARK: - Convenience
⋮----
/// Check if this event is a reply to another event
public var isReply: Bool {
⋮----
/// Get the event ID this is replying to
public var replyEventId: EventID? {
let replyTag = tags.first { tag in
⋮----
/// Check if this event is ephemeral
public var isEphemeral: Bool {
⋮----
/// Check if this event is replaceable
public var isReplaceable: Bool {
// Kind 0 (metadata) and kind 3 (contacts) are replaceable
// Also kinds 10000-19999 are replaceable
⋮----
/// Check if this event is parameterized replaceable
public var isParameterizedReplaceable: Bool {
⋮----
/// Get the tag address for replaceable events
public var tagAddress: String {
⋮----
// Parameterized replaceable events
let dTag = tags.first(where: { $0.count >= 2 && $0[0] == "d" })?[1] ?? ""
⋮----
// Regular replaceable events
⋮----
/// Get the value of a tag by name
public func tagValue(_ name: String) -> String? {
⋮----
// MARK: - Serialization
⋮----
/// Returns the raw event as a dictionary compatible with Nostr protocol
/// This matches the rawEvent() method from @ndk/ndk-core
public func rawEvent() -> [String: Any] {
var result: [String: Any] = [
⋮----
/// Serialize event to JSON string
public func serialize() throws -> String {
⋮----
/// Alias for serialize() - serialize event to JSON string
public func toJSON() throws -> String {
⋮----
// MARK: - Event Reactions
⋮----
/// React to this event with the given content (usually an emoji)
/// @param content The reaction content (e.g., "+", "-", "❤️", "🤙", "⚡", etc.)
/// @param publish Whether to automatically publish the reaction event
/// @returns The reaction event
public func react(content: String, publish: Bool = true) async throws -> NDKEvent {
⋮----
// Create the reaction event
let reactionEvent = NDKEvent(
pubkey: "", // Will be set by signer
⋮----
// Tag this event
⋮----
// Also tag the author of the event being reacted to
⋮----
// Sign the reaction event
⋮----
// Publish if requested
⋮----
// MARK: - NIP-19 Encoding
⋮----
/// Encode this event to bech32 format according to NIP-19
/// Returns note1 for simple events, nevent1 for events with metadata, naddr1 for replaceable events
public func encode(includeRelays: Bool = false) throws -> String {
⋮----
// For parameterized replaceable events, use naddr encoding
⋮----
let identifier = tagValue("d") ?? ""
let relays = includeRelays ? getRelayHints() : nil
⋮----
// For other replaceable events, use naddr encoding with empty identifier
⋮----
// For non-replaceable events, decide between note and nevent
⋮----
// Simple note encoding nsec1rfwvk7tvws2hy0sf25wu96qhefr9c0xrlvllymwe6new8e59lgdsz23vuj
⋮----
/// Get relay hints for this event
private func getRelayHints() -> [String]? {
var relays: [String] = []
⋮----
// Add relay where this event was received from
⋮----
// Add relays from NDK instance if available
⋮----
let ndkRelays = ndk.relays.prefix(3).map { $0.url }
⋮----
// Remove duplicates and limit to 3 relays (as recommended by NIP-19)
let uniqueRelays = Array(Set(relays)).prefix(3)
⋮----
/// Check if this event has metadata that makes nevent encoding worthwhile
private func hasMetadataWorthyOfNevent() -> Bool {
// Use nevent if the event has non-standard kind or has important tags
⋮----
// MARK: - Character extension for hex validation
⋮----
var isHexDigit: Bool {
</file>

<file path="Sources/NDKSwift/Subscription/NDKSubscription.swift">
/// Actor for managing subscription state in a thread-safe manner
actor SubscriptionState {
private var activeRelays: Set<NDKRelay> = []
⋮----
func addRelay(_ relay: NDKRelay) {
⋮----
func getAllRelays() -> Set<NDKRelay> {
⋮----
func removeAllRelays() -> Set<NDKRelay> {
let relays = activeRelays
⋮----
func contains(_ relay: NDKRelay) -> Bool {
⋮----
var count: Int {
⋮----
/// Subscription options
public struct NDKSubscriptionOptions {
/// Whether to close the subscription on EOSE
public var closeOnEose: Bool = false
⋮----
/// Cache strategy
public var cacheStrategy: NDKCacheStrategy = .cacheFirst
⋮----
/// Maximum number of events to receive
public var limit: Int?
⋮----
/// Timeout for the subscription
public var timeout: TimeInterval?
⋮----
/// Specific relays to use for this subscription
public var relays: Set<NDKRelay>?
⋮----
public init() {}
⋮----
/// Cache strategy for subscriptions
public enum NDKCacheStrategy {
case cacheFirst // Check cache first, then relays
case cacheOnly // Only check cache
case relayOnly // Only check relays
case parallel // Check cache and relays in parallel
⋮----
/// Delegate for subscription events
public protocol NDKSubscriptionDelegate: AnyObject {
⋮----
/// Real implementation of NDKSubscription
public final class NDKSubscription {
/// Unique subscription ID
public let id: String
⋮----
/// Filters for this subscription
public let filters: [NDKFilter]
⋮----
public let options: NDKSubscriptionOptions
⋮----
/// Reference to NDK instance
public weak var ndk: NDK?
⋮----
/// Subscription delegate
public weak var delegate: NDKSubscriptionDelegate?
⋮----
/// Events received so far
public private(set) var events: [NDKEvent] = []
⋮----
/// Whether EOSE has been received from all relays
public private(set) var eoseReceived: Bool = false
⋮----
/// Track EOSE received from individual relays
private var eoseReceivedFromRelays: Set<String> = []
private let eoseReceivedLock = NSLock()
⋮----
/// Whether the subscription is active
public private(set) var isActive: Bool = false
⋮----
/// Whether the subscription is closed
public private(set) var isClosed: Bool = false
⋮----
/// Thread-safe relay state management
private let relayState = SubscriptionState()
⋮----
/// Event deduplication - protected by lock
private var receivedEventIds: Set<EventID> = []
private let receivedEventIdsLock = NSLock()
⋮----
/// Timer for timeout
private var timeoutTimer: Timer?
⋮----
/// Event callbacks - protected by lock
var eventCallbacks: [(NDKEvent) -> Void] = []
private let eventCallbacksLock = NSLock()
⋮----
/// EOSE callbacks - protected by lock
var eoseCallbacks: [() -> Void] = []
private let eoseCallbacksLock = NSLock()
⋮----
/// Error callbacks - protected by lock
var errorCallbacks: [(Error) -> Void] = []
private let errorCallbacksLock = NSLock()
⋮----
/// Events array lock
private let eventsLock = NSLock()
⋮----
/// State locks
private let stateLock = NSLock()
⋮----
/// Task that handles registration with the subscription manager
internal var registrationTask: Task<Void, Never>?
⋮----
public init(
⋮----
deinit {
⋮----
// MARK: - Callback Registration
⋮----
/// Add a callback for events
public func onEvent(_ callback: @escaping (NDKEvent) -> Void) {
⋮----
/// Add a callback for EOSE
public func onEOSE(_ callback: @escaping () -> Void) {
⋮----
/// Add a callback for errors
public func onError(_ callback: @escaping (Error) -> Void) {
⋮----
// MARK: - Subscription Control
⋮----
/// Start the subscription
public func start() {
⋮----
let shouldStart = !isActive && !isClosed
⋮----
// Start with cache if needed
⋮----
// Query relays if needed
⋮----
/// Close the subscription
public func close() {
⋮----
let shouldClose = !isClosed
⋮----
// Close on all active relays using subscription manager
// Capture id before Task to avoid accessing self in async context
let subscriptionId = id
⋮----
let relays = await relayState.removeAllRelays()
⋮----
// Thread-safe callback cleanup
⋮----
// MARK: - Cache Handling
⋮----
private func checkCache() {
⋮----
let cachedEvents = await cache.query(subscription: self)
⋮----
// If cache-only strategy, mark as EOSE
⋮----
// MARK: - Relay Handling
⋮----
private func queryRelays() {
⋮----
let relaysToUse = options.relays ?? Set(ndk.relays)
⋮----
// Only track the relay state - the main subscription manager handles the actual subscription
⋮----
// Note: Don't call relay.subscriptionManager.addSubscription() as it's handled by the main NDKSubscriptionManager
⋮----
// MARK: - Event Handling
⋮----
/// Handle an event received from a relay
public func handleEvent(_ event: NDKEvent, fromRelay relay: NDKRelay?) {
⋮----
let closed = isClosed
⋮----
// Thread-safe event deduplication
⋮----
let alreadyReceived = receivedEventIds.contains(eventId)
⋮----
return // Deduplicate
⋮----
// Check if event matches our filters
⋮----
// Thread-safe event storage
⋮----
let currentEventCount = events.count
⋮----
// Store in cache if available
⋮----
// Thread-safe callback execution
⋮----
let callbacks = eventCallbacks
⋮----
// Check limit with thread-safe access
⋮----
/// Handle EOSE (End of Stored Events)
public func handleEOSE(fromRelay relay: NDKRelay? = nil) {
// Track EOSE from this specific relay
let relayUrl = relay?.url ?? "unknown"
var shouldComplete = false
⋮----
// Check if we've received EOSE from all expected relays
let expectedRelays = options.relays ?? Set(ndk?.relays ?? [])
let expectedRelayUrls = Set(expectedRelays.map { $0.url })
let allEoseReceived = expectedRelayUrls.isSubset(of: eoseReceivedFromRelays)
⋮----
let alreadyCompleted = eoseReceived
⋮----
let callbacks = eoseCallbacks
⋮----
/// Handle subscription error
public func handleError(_ error: Error) {
⋮----
let callbacks = errorCallbacks
⋮----
// MARK: - Async Support (for modern Swift)
⋮----
/// Stream of events as an async sequence
public func eventStream() -> AsyncStream<NDKEvent> {
⋮----
let callback: (NDKEvent) -> Void = { event in
⋮----
// Thread-safe callback registration
⋮----
// Handle completion
let eoseCallback = {
⋮----
// Thread-safe cleanup when stream is cancelled
⋮----
/// Wait for EOSE as async
public func waitForEOSE() async {
⋮----
let received = eoseReceived
⋮----
let callback = {
⋮----
// MARK: - Private Helpers
⋮----
private func setupTimeoutIfNeeded() {
⋮----
// MARK: - Equatable & Hashable
⋮----
public func hash(into hasher: inout Hasher) {
⋮----
// MARK: - Subscription grouping utilities
⋮----
/// Check if this subscription can be merged with another
func canMerge(with other: NDKSubscription) -> Bool {
// Basic checks
⋮----
// Check if filters can be merged
⋮----
/// Merge with another subscription
func merge(with other: NDKSubscription) -> NDKSubscription? {
⋮----
// Combine filters
var mergedFilters: [NDKFilter] = []
⋮----
// Use combined options
var mergedOptions = options
</file>

<file path="Sources/NDKSwift/Utils/Crypto.swift">
/// Cryptographic utilities for Nostr
public enum Crypto {
/// Errors that can occur during cryptographic operations
public enum CryptoError: Error, LocalizedError {
⋮----
public var errorDescription: String? {
⋮----
/// Generate a new private key
public static func generatePrivateKey() -> PrivateKey {
var bytes = [UInt8](repeating: 0, count: 32)
⋮----
// Fallback for Linux
⋮----
/// Derive public key from private key using secp256k1
public static func getPublicKey(from privateKey: PrivateKey) throws -> PublicKey {
⋮----
// For Schnorr signatures in Nostr, we need the x-only public key (32 bytes)
let privKey = try P256K.Schnorr.PrivateKey(dataRepresentation: privKeyData)
let xonlyPubKey = privKey.publicKey.xonly
⋮----
/// Sign a message with a private key using Schnorr signatures
public static func sign(message: Data, privateKey: PrivateKey) throws -> Signature {
⋮----
// For Nostr, we sign the message directly (it's already the event ID hash)
// We pass nil for auxiliaryRand to use the default BIP340 nonce function
var messageBytes = Array(message)
let signature = try privKey.signature(message: &messageBytes, auxiliaryRand: nil)
⋮----
/// Verify a signature using Schnorr verification
public static func verify(signature: Signature, message: Data, publicKey: PublicKey) throws -> Bool {
⋮----
let xonlyKey = P256K.Schnorr.XonlyKey(dataRepresentation: pubKeyData)
let schnorrSig = try P256K.Schnorr.SchnorrSignature(dataRepresentation: sigData)
⋮----
/// SHA256 hash
public static func sha256(_ data: Data) -> Data {
⋮----
/// Generate random bytes
public static func randomBytes(count: Int) -> Data {
var bytes = [UInt8](repeating: 0, count: count)
⋮----
/// NIP-04 Encryption (deprecated but still used)
⋮----
/// Encrypt a message using NIP-04
static func nip04Encrypt(message: String, privateKey: PrivateKey, publicKey: PublicKey) throws -> String {
// Simplified implementation for development
// In production, use proper ECDH and AES encryption
let iv = randomBytes(count: 16)
let encrypted = try encryptAES(message: message, key: privateKey + publicKey, iv: iv)
⋮----
/// Decrypt a message using NIP-04
static func nip04Decrypt(encrypted: String, privateKey: PrivateKey, publicKey: PublicKey) throws -> String {
⋮----
let parts = encrypted.split(separator: "?")
⋮----
private static func encryptAES(message: String, key: String, iv: Data) throws -> Data {
⋮----
// Use first 32 bytes of key for AES-256
let aesKey = Array(keyData.prefix(32))
let aes = try AES(key: aesKey, blockMode: CBC(iv: Array(iv)))
let encrypted = try aes.encrypt(Array(messageData))
⋮----
private static func decryptAES(encrypted: Data, key: String, iv: Data) throws -> String {
⋮----
let decrypted = try aes.decrypt(Array(encrypted))
</file>

<file path="Package.swift">
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.
⋮----
let package = Package(
⋮----
// Products define the executables and libraries a package produces, making them visible to other packages.
⋮----
// Targets are the basic building blocks of a package, defining a module or a test suite.
// Targets can depend on other targets in this package and products from dependencies.
</file>

<file path="Sources/NDKSwift/Core/NDK.swift">
/// Main entry point for NDKSwift
public final class NDK {
/// Active signer for this NDK instance
public var signer: NDKSigner?
⋮----
/// Cache adapter for storing events
public var cacheAdapter: NDKCacheAdapter?
⋮----
/// Active user (derived from signer)
public var activeUser: NDKUser? {
// This will need to be async or cached
⋮----
/// Relay pool
let relayPool: NDKRelayPool
⋮----
/// Event repository
private let eventRepository: NDKEventRepository
⋮----
/// Published events tracking (for OK message handling)
private var publishedEvents: [EventID: NDKEvent] = [:]
⋮----
/// Subscription manager
private var subscriptionManager: NDKSubscriptionManager!
⋮----
/// Whether debug mode is enabled
public var debugMode: Bool = false
⋮----
/// Signature verification configuration
public var signatureVerificationConfig: NDKSignatureVerificationConfig
⋮----
/// Signature verification sampler
let signatureVerificationSampler: NDKSignatureVerificationSampler
⋮----
/// Signature verification delegate
public weak var signatureVerificationDelegate: NDKSignatureVerificationDelegate?
⋮----
/// Payment router for handling zaps and payments
public var paymentRouter: NDKPaymentRouter?
⋮----
/// Wallet configuration
public var walletConfig: NDKWalletConfig? {
⋮----
// MARK: - Outbox Model Support
⋮----
/// Outbox configuration
public var outboxConfig: NDKOutboxConfig = .default
⋮----
/// Outbox tracker (lazy)
var _outboxTracker: NDKOutboxTracker?
⋮----
/// Relay ranker (lazy)
var _relayRanker: NDKRelayRanker?
⋮----
/// Relay selector (lazy)
var _relaySelector: NDKRelaySelector?
⋮----
/// Publishing strategy (lazy)
var _publishingStrategy: NDKPublishingStrategy?
⋮----
/// Fetching strategy (lazy)
var _fetchingStrategy: NDKFetchingStrategy?
⋮----
// MARK: - Subscription Tracking
⋮----
/// Subscription tracker for monitoring and debugging
public let subscriptionTracker: NDKSubscriptionTracker
⋮----
/// Configuration for subscription tracking
public struct SubscriptionTrackingConfig {
/// Whether to track closed subscriptions for debugging
public var trackClosedSubscriptions: Bool
⋮----
/// Maximum number of closed subscriptions to remember
public var maxClosedSubscriptions: Int
⋮----
public init(
⋮----
public static let `default` = SubscriptionTrackingConfig()
⋮----
// MARK: - Profile Management
// Profile management will be added later
⋮----
// MARK: - Initialization
⋮----
// Profile manager will be initialized later
⋮----
// Initialize subscription manager after all properties are set
⋮----
// Add initial relays
⋮----
// MARK: - Relay Management
⋮----
/// Add a relay to the pool
⋮----
public func addRelay(_ url: RelayURL) -> NDKRelay {
let relay = relayPool.addRelay(url)
⋮----
// Set up connection state observer to publish queued events
⋮----
/// Remove a relay from the pool
public func removeRelay(_ url: RelayURL) {
⋮----
/// Get all relays
public var relays: [NDKRelay] {
⋮----
/// Connect to all relays
public func connect() async {
⋮----
/// Disconnect from all relays
public func disconnect() async {
⋮----
/// Get pool of relays
public var pool: NDKRelayPool {
⋮----
// MARK: - Event Publishing
⋮----
/// Publish an event
⋮----
public func publish(_ event: NDKEvent) async throws -> Set<NDKRelay> {
// Sign event if not already signed
⋮----
// Set NDK instance and sign (this will also generate content tags)
⋮----
// Validate event
⋮----
// Store in cache if available
⋮----
// Track this event for OK message handling
⋮----
// Get all relays we want to publish to
let targetRelays = relayPool.relays
⋮----
// Publish to connected relays
let publishedRelays = await relayPool.publishEvent(event)
⋮----
// Update event's relay publish statuses
⋮----
// Find relays that weren't connected or failed
let unpublishedRelayUrls = targetRelays
⋮----
// Store unpublished event for later retry when relays connect
⋮----
// Mark these relays as pending
⋮----
let noteId = (try? Bech32.note(from: event.id ?? "")) ?? event.id ?? "unknown"
⋮----
let relayUrls = publishedRelays.map { $0.url }.joined(separator: ", ")
⋮----
/// Publish an event to specific relays by URL
public func publish(event: NDKEvent, to relayUrls: Set<String>) async throws -> Set<NDKRelay> {
// Sign the event if needed
⋮----
// Use relays from the pool or add them if needed
var targetRelays: Set<NDKRelay> = []
⋮----
let normalizedUrl = URLNormalizer.tryNormalizeRelayUrl(url) ?? url
⋮----
// Check if relay is already in the pool
⋮----
// Add relay to pool
let relay = addRelay(normalizedUrl)
⋮----
// Connect to relays that aren't already connected
⋮----
// Publish to the specific relays
var publishedRelays: Set<NDKRelay> = []
⋮----
let eventMessage = NostrMessage.event(subscriptionId: nil, event: event)
⋮----
// MARK: - Subscriptions
⋮----
/// Subscribe to events matching the given filters
public func subscribe(
⋮----
var subscriptionOptions = options
⋮----
let subscription = NDKSubscription(
⋮----
// Store the subscription immediately in a sync manner to avoid race conditions
⋮----
/// Fetch events matching the given filters
public func fetchEvents(
⋮----
var options = NDKSubscriptionOptions()
⋮----
let subscription = subscribe(filters: filters, options: options)
⋮----
// Wait for registration to complete before starting
⋮----
// Start the subscription
⋮----
// Wait for EOSE using the new callback-based approach
⋮----
/// Fetch a single event by ID (hex or bech32 format)
public func fetchEvent(_ idOrBech32: String, relays: Set<NDKRelay>? = nil) async throws -> NDKEvent? {
let filter = try NostrIdentifier.createFilter(from: idOrBech32)
let events = try await fetchEvents(filters: [filter], relays: relays)
⋮----
/// Fetch a single event matching the filter
public func fetchEvent(_ filter: NDKFilter, relays: Set<NDKRelay>? = nil) async throws -> NDKEvent? {
⋮----
// MARK: - Subscription Manager Integration
⋮----
/// Process an event received from a relay (called by relay connections)
func processEvent(_ event: NDKEvent, from relay: NDKRelay) {
// Mark event as seen on this relay
⋮----
// Get current stats
var currentStats = relay.getSignatureStats()
⋮----
// Verify signature with sampling
let verificationResult = await signatureVerificationSampler.verifyEvent(
⋮----
// Update stats back to relay
⋮----
// Invalid signature - don't process this event
⋮----
// Already verified
⋮----
// Skipped due to sampling
⋮----
// Process the event
⋮----
/// Process EOSE received from a relay (called by relay connections)
func processEOSE(subscriptionId: String, from relay: NDKRelay) {
⋮----
/// Get subscription manager statistics
public func getSubscriptionStats() async -> NDKSubscriptionManager.SubscriptionStats {
⋮----
/// Process OK message from relay (called by relay connections)
func processOKMessage(eventId: EventID, accepted: Bool, message: String?, from relay: NDKRelay) {
// Find the event in our published events
⋮----
// Store the OK message
⋮----
// Update publish status based on OK response
⋮----
let reason = message ?? "Rejected by relay"
⋮----
// MARK: - User Management
⋮----
/// Get a user by public key
public func getUser(_ pubkey: PublicKey) -> NDKUser {
let user = NDKUser(pubkey: pubkey)
⋮----
/// Get a user from npub
public func getUser(npub: String) -> NDKUser? {
⋮----
// MARK: - Queued Events
⋮----
/// Publish events that were queued while relay was disconnected
private func publishQueuedEvents(for relay: NDKRelay) async {
⋮----
let queuedEvents = await cache.getUnpublishedEvents(for: relay.url)
⋮----
// Re-track for OK message handling
⋮----
// Send the event
⋮----
// Update status
⋮----
// Remove from unpublished queue
⋮----
// Update status to failed
⋮----
// MARK: - Signature Verification
⋮----
/// Get signature verification statistics
public func getSignatureVerificationStats() async -> (totalVerifications: Int, failedVerifications: Int, blacklistedRelays: Int) {
⋮----
/// Check if a relay is blacklisted
public func isRelayBlacklisted(_ relay: NDKRelay) async -> Bool {
⋮----
/// Get all blacklisted relay URLs
public func getBlacklistedRelays() async -> Set<String> {
⋮----
/// Clear the signature verification cache
public func clearSignatureCache() async {
⋮----
/// Set the signature verification delegate
public func setSignatureVerificationDelegate(_ delegate: NDKSignatureVerificationDelegate) async {
⋮----
// MARK: - Relay Pool Implementation
⋮----
public class NDKRelayPool {
var relaysByUrl: [RelayURL: NDKRelay] = [:]
⋮----
func addRelay(_ url: RelayURL) -> NDKRelay {
// Normalize the URL before storing
⋮----
let relay = NDKRelay(url: normalizedUrl)
⋮----
func removeRelay(_ url: RelayURL) {
// Normalize the URL before removing
⋮----
var relays: [NDKRelay] {
⋮----
/// Get currently connected relays
public func connectedRelays() -> [NDKRelay] {
⋮----
func connectAll() async {
⋮----
func disconnectAll() async {
⋮----
/// Publish an event to all connected relays
func publishEvent(_ event: NDKEvent) async -> Set<NDKRelay> {
let connectedRelays = self.connectedRelays()
⋮----
// Failed to send to this relay
⋮----
// MARK: - Event Repository Implementation
⋮----
class NDKEventRepository {
private var events: [EventID: NDKEvent] = [:]
private let queue = DispatchQueue(label: "com.ndkswift.eventrepository", attributes: .concurrent)
⋮----
func addEvent(_ event: NDKEvent) {
⋮----
func getEvent(_ eventId: EventID) -> NDKEvent? {
⋮----
func getAllEvents() -> [NDKEvent] {
⋮----
func clear() {
</file>

</files>
